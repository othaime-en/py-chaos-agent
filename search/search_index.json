{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Python-based chaos engineering sidecar tool for testing the resilience of containerized applications. Overview \u00b6 Py-Chaos-Agent runs alongside your application containers to inject controlled failures and validate system behavior under stress. It's designed to help you build more resilient systems by proactively testing how they handle various failure scenarios. Key Features \u00b6 Multiple Failure Modes : CPU stress, memory pressure, process termination, network latency Flexible Configuration : YAML-based configuration with probability controls Kubernetes Native : Designed as a sidecar container with proper security contexts Observable : Prometheus metrics for monitoring chaos experiments Safe by Default : Self-protection mechanisms and dry-run mode Infrastructure as Code : Terraform modules for AWS EKS deployment Quick Example \u00b6 agent : interval_seconds : 10 dry_run : false failures : cpu : enabled : true probability : 0.3 duration_seconds : 5 cores : 1 Why Chaos Engineering? \u00b6 Chaos engineering helps you: Identify weaknesses before they cause outages Build confidence in system resilience Validate monitoring and alerting systems Improve incident response procedures Test auto-scaling and recovery mechanisms Getting Started \u00b6 Ready to start chaos testing? Check out our Quick Start Guide to get up and running in minutes. Safety First \u00b6 Testing Environments Only This tool is designed for testing environments only. Always exercise caution and never run in production without proper safeguards and approval. See our Safety & Ethics guidelines for responsible chaos engineering practices. Project Status \u00b6 Py-Chaos-Agent is actively maintained and used in development and staging environments. We welcome contributions and feedback from the community. License \u00b6 This project is licensed under the MIT License - see the LICENSE file for details.","title":"Home"},{"location":"#overview","text":"Py-Chaos-Agent runs alongside your application containers to inject controlled failures and validate system behavior under stress. It's designed to help you build more resilient systems by proactively testing how they handle various failure scenarios.","title":"Overview"},{"location":"#key-features","text":"Multiple Failure Modes : CPU stress, memory pressure, process termination, network latency Flexible Configuration : YAML-based configuration with probability controls Kubernetes Native : Designed as a sidecar container with proper security contexts Observable : Prometheus metrics for monitoring chaos experiments Safe by Default : Self-protection mechanisms and dry-run mode Infrastructure as Code : Terraform modules for AWS EKS deployment","title":"Key Features"},{"location":"#quick-example","text":"agent : interval_seconds : 10 dry_run : false failures : cpu : enabled : true probability : 0.3 duration_seconds : 5 cores : 1","title":"Quick Example"},{"location":"#why-chaos-engineering","text":"Chaos engineering helps you: Identify weaknesses before they cause outages Build confidence in system resilience Validate monitoring and alerting systems Improve incident response procedures Test auto-scaling and recovery mechanisms","title":"Why Chaos Engineering?"},{"location":"#getting-started","text":"Ready to start chaos testing? Check out our Quick Start Guide to get up and running in minutes.","title":"Getting Started"},{"location":"#safety-first","text":"Testing Environments Only This tool is designed for testing environments only. Always exercise caution and never run in production without proper safeguards and approval. See our Safety & Ethics guidelines for responsible chaos engineering practices.","title":"Safety First"},{"location":"#project-status","text":"Py-Chaos-Agent is actively maintained and used in development and staging environments. We welcome contributions and feedback from the community.","title":"Project Status"},{"location":"#license","text":"This project is licensed under the MIT License - see the LICENSE file for details.","title":"License"},{"location":"safety/","text":"Chaos engineering is a powerful tool for building resilient systems, but it must be used responsibly. Core Principles \u00b6 Only Test Systems You Own \u00b6 Critical Only use Py-Chaos-Agent on systems you own or have explicit written permission to test. Unauthorized chaos testing is unethical and potentially illegal. Never Use in Production Without Approval \u00b6 Production chaos engineering requires: Formal approval from leadership and stakeholders Comprehensive monitoring and alerting Immediate rollback procedures On-call team availability Clear runbook documentation Gradual rollout strategy Start Small and Controlled \u00b6 Begin your chaos journey with: Dry run mode - Test configuration without injection Development environments - Low-risk testing grounds Low probability - Start with 5-10% injection rates Single failure modes - Test one thing at a time Short durations - Keep failures brief initially Safety Features \u00b6 Built-in Protections \u00b6 Py-Chaos-Agent includes several safety mechanisms: Self-protection : Won't terminate its own process Dry run mode : Test without actual injection Configurable probabilities : Control injection frequency Duration limits : Automatic cleanup after timeout Metrics and logging : Full observability Configuration Safety \u00b6 agent : interval_seconds : 10 # Don't set too low dry_run : true # Start with dry run failures : cpu : probability : 0.1 # Start with low probability duration_seconds : 5 # Keep durations short Ethical Guidelines \u00b6 Minimize Harm \u00b6 Test during low-traffic periods Have rollback plans ready Monitor system health continuously Stop immediately if issues arise Notify relevant teams before testing Respect User Impact \u00b6 Remember that chaos testing can affect: User experience and satisfaction Service availability System performance Team on-call burden Balance testing goals with user needs. Transparent Communication \u00b6 Document all chaos experiments Notify stakeholders before testing Share results and learnings Be honest about failures and incidents Best Practices \u00b6 Pre-Testing Checklist \u00b6 Before running chaos experiments: Have explicit permission to test Verify monitoring and alerting works Document expected behavior Prepare rollback procedures Notify relevant teams Set up logging and metrics collection Start with dry run mode Test during appropriate hours During Testing \u00b6 Monitor metrics continuously Watch for unexpected behavior Be ready to stop immediately Document all observations Keep stakeholders informed Post-Testing \u00b6 Analyze results thoroughly Document lessons learned Share findings with team Update runbooks and documentation Plan improvements based on findings Risk Management \u00b6 Assess Before Testing \u00b6 Consider these factors: System criticality : How important is the system? User impact : How many users will be affected? Recovery time : How quickly can we recover? Team availability : Is support available? Monitoring coverage : Can we detect issues? Gradual Rollout \u00b6 Increase chaos intensity gradually: Week 1 : Dry run mode, verify configuration Week 2 : Enable one failure mode at 10% probability Week 3 : Increase to 20-30% if stable Week 4 : Add second failure mode Month 2 : Fine-tune based on learnings Know When to Stop \u00b6 Stop chaos testing immediately if: Customer-impacting incidents occur System behavior becomes unpredictable Monitoring or alerting fails Team is overwhelmed Stakeholders request a halt Legal Considerations \u00b6 Terms of Service \u00b6 Ensure chaos testing doesn't violate: Cloud provider terms of service Service level agreements (SLAs) Compliance requirements Regulatory constraints Liability \u00b6 Document all testing activities Maintain audit logs Follow organizational policies Consult legal team for production testing Getting Help \u00b6 If you have questions about safe chaos engineering: Review Principles of Chaos Engineering Join chaos engineering communities Consult with SRE/DevOps teams Start small and learn incrementally Report Issues \u00b6 If you discover a safety issue with Py-Chaos-Agent: Open a security issue on GitHub Contact maintainers directly Don't disclose publicly until fixed Remember: The goal of chaos engineering is to build better systems, not to cause harm. Always prioritize safety, ethics, and user well-being.","title":"Safety & Ethics"},{"location":"safety/#core-principles","text":"","title":"Core Principles"},{"location":"safety/#only-test-systems-you-own","text":"Critical Only use Py-Chaos-Agent on systems you own or have explicit written permission to test. Unauthorized chaos testing is unethical and potentially illegal.","title":"Only Test Systems You Own"},{"location":"safety/#never-use-in-production-without-approval","text":"Production chaos engineering requires: Formal approval from leadership and stakeholders Comprehensive monitoring and alerting Immediate rollback procedures On-call team availability Clear runbook documentation Gradual rollout strategy","title":"Never Use in Production Without Approval"},{"location":"safety/#start-small-and-controlled","text":"Begin your chaos journey with: Dry run mode - Test configuration without injection Development environments - Low-risk testing grounds Low probability - Start with 5-10% injection rates Single failure modes - Test one thing at a time Short durations - Keep failures brief initially","title":"Start Small and Controlled"},{"location":"safety/#safety-features","text":"","title":"Safety Features"},{"location":"safety/#built-in-protections","text":"Py-Chaos-Agent includes several safety mechanisms: Self-protection : Won't terminate its own process Dry run mode : Test without actual injection Configurable probabilities : Control injection frequency Duration limits : Automatic cleanup after timeout Metrics and logging : Full observability","title":"Built-in Protections"},{"location":"safety/#configuration-safety","text":"agent : interval_seconds : 10 # Don't set too low dry_run : true # Start with dry run failures : cpu : probability : 0.1 # Start with low probability duration_seconds : 5 # Keep durations short","title":"Configuration Safety"},{"location":"safety/#ethical-guidelines","text":"","title":"Ethical Guidelines"},{"location":"safety/#minimize-harm","text":"Test during low-traffic periods Have rollback plans ready Monitor system health continuously Stop immediately if issues arise Notify relevant teams before testing","title":"Minimize Harm"},{"location":"safety/#respect-user-impact","text":"Remember that chaos testing can affect: User experience and satisfaction Service availability System performance Team on-call burden Balance testing goals with user needs.","title":"Respect User Impact"},{"location":"safety/#transparent-communication","text":"Document all chaos experiments Notify stakeholders before testing Share results and learnings Be honest about failures and incidents","title":"Transparent Communication"},{"location":"safety/#best-practices","text":"","title":"Best Practices"},{"location":"safety/#pre-testing-checklist","text":"Before running chaos experiments: Have explicit permission to test Verify monitoring and alerting works Document expected behavior Prepare rollback procedures Notify relevant teams Set up logging and metrics collection Start with dry run mode Test during appropriate hours","title":"Pre-Testing Checklist"},{"location":"safety/#during-testing","text":"Monitor metrics continuously Watch for unexpected behavior Be ready to stop immediately Document all observations Keep stakeholders informed","title":"During Testing"},{"location":"safety/#post-testing","text":"Analyze results thoroughly Document lessons learned Share findings with team Update runbooks and documentation Plan improvements based on findings","title":"Post-Testing"},{"location":"safety/#risk-management","text":"","title":"Risk Management"},{"location":"safety/#assess-before-testing","text":"Consider these factors: System criticality : How important is the system? User impact : How many users will be affected? Recovery time : How quickly can we recover? Team availability : Is support available? Monitoring coverage : Can we detect issues?","title":"Assess Before Testing"},{"location":"safety/#gradual-rollout","text":"Increase chaos intensity gradually: Week 1 : Dry run mode, verify configuration Week 2 : Enable one failure mode at 10% probability Week 3 : Increase to 20-30% if stable Week 4 : Add second failure mode Month 2 : Fine-tune based on learnings","title":"Gradual Rollout"},{"location":"safety/#know-when-to-stop","text":"Stop chaos testing immediately if: Customer-impacting incidents occur System behavior becomes unpredictable Monitoring or alerting fails Team is overwhelmed Stakeholders request a halt","title":"Know When to Stop"},{"location":"safety/#legal-considerations","text":"","title":"Legal Considerations"},{"location":"safety/#terms-of-service","text":"Ensure chaos testing doesn't violate: Cloud provider terms of service Service level agreements (SLAs) Compliance requirements Regulatory constraints","title":"Terms of Service"},{"location":"safety/#liability","text":"Document all testing activities Maintain audit logs Follow organizational policies Consult legal team for production testing","title":"Liability"},{"location":"safety/#getting-help","text":"If you have questions about safe chaos engineering: Review Principles of Chaos Engineering Join chaos engineering communities Consult with SRE/DevOps teams Start small and learn incrementally","title":"Getting Help"},{"location":"safety/#report-issues","text":"If you discover a safety issue with Py-Chaos-Agent: Open a security issue on GitHub Contact maintainers directly Don't disclose publicly until fixed Remember: The goal of chaos engineering is to build better systems, not to cause harm. Always prioritize safety, ethics, and user well-being.","title":"Report Issues"},{"location":"development/development/","text":"Getting Started \u00b6 Prerequisites \u00b6 Python 3.10 or higher Docker and Docker Compose Git Virtual environment tool (venv, virtualenv, or conda) Initial Setup \u00b6 # Clone the repository git clone https://github.com/yourusername/py-chaos-agent.git cd py-chaos-agent # Create virtual environment python -m venv venv # Activate virtual environment source venv/bin/activate # On Linux/Mac # or venv \\S cripts \\a ctivate # On Windows # Install dependencies pip install -r requirements.txt -r requirements-dev.txt # Verify installation python -c \"import psutil, yaml, prometheus_client; print('Dependencies OK')\" Project Structure \u00b6 py-chaos-agent/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 agent.py # Main agent loop \u2502 \u251c\u2500\u2500 config.py # Configuration loading \u2502 \u251c\u2500\u2500 metrics.py # Prometheus metrics \u2502 \u2514\u2500\u2500 failures/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 cpu.py # CPU stress injection \u2502 \u251c\u2500\u2500 memory.py # Memory pressure injection \u2502 \u251c\u2500\u2500 process.py # Process termination \u2502 \u2514\u2500\u2500 network.py # Network latency injection \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 conftest.py # Test fixtures \u2502 \u251c\u2500\u2500 test_config.py # Configuration tests \u2502 \u251c\u2500\u2500 test_failures.py # Failure module tests \u2502 \u251c\u2500\u2500 test_integration.py # Integration tests \u2502 \u2514\u2500\u2500 test_metrics.py # Metrics tests \u251c\u2500\u2500 docker/ \u2502 \u251c\u2500\u2500 Dockerfile # Chaos agent image \u2502 \u251c\u2500\u2500 Dockerfile.target # Target app image \u2502 \u2514\u2500\u2500 target-app.py # Simple test application \u251c\u2500\u2500 k8s/ \u2502 \u2514\u2500\u2500 chaos-demo.yaml # Kubernetes manifests \u251c\u2500\u2500 terraform/ \u2502 \u2514\u2500\u2500 *.tf # Infrastructure as code \u251c\u2500\u2500 docs/ \u2502 \u2514\u2500\u2500 *.md # Documentation \u251c\u2500\u2500 config.yaml # Default configuration \u251c\u2500\u2500 docker-compose.yml # Local development setup \u251c\u2500\u2500 requirements.txt # Runtime dependencies \u251c\u2500\u2500 requirements-dev.txt # Development dependencies \u2514\u2500\u2500 README.md Development Workflow \u00b6 Running Tests \u00b6 # Run all tests pytest # Run with verbose output pytest -v # Run specific test file pytest tests/test_failures.py # Run specific test function pytest tests/test_failures.py::TestCPUFailures::test_inject_cpu_dry_run # Run with coverage report pytest --cov = src --cov-report = term-missing # Generate HTML coverage report pytest --cov = src --cov-report = html # Open htmlcov/index.html in browser # Run only fast tests (skip slow/integration tests) pytest -m \"not slow\" Code Quality \u00b6 # Format code with Black black src tests # Check code style with flake8 flake8 src tests # Type checking with mypy mypy src # Run all quality checks (what CI runs) black --check src tests flake8 src tests mypy src --install-types --non-interactive Local Testing \u00b6 # Test with dry-run mode python -m src.agent # Run with Docker Compose docker-compose up --build # View logs docker-compose logs -f chaos-agent # Stop containers docker-compose down Debugging \u00b6 # Run agent with Python debugger python -m pdb -m src.agent # Or use breakpoints in code import pdb ; pdb.set_trace () # Debug in container docker-compose run --rm chaos-agent /bin/bash Adding New Features \u00b6 Adding a New Failure Type \u00b6 1. Create the module # src/failures/disk.py from ..metrics import INJECTIONS_TOTAL , INJECTION_ACTIVE def inject_disk ( config : dict , dry_run : bool = False ): \"\"\"Inject disk I/O chaos.\"\"\" operation = config . get ( \"operation\" , \"fill\" ) size_mb = config . get ( \"size_mb\" , 100 ) if dry_run : print ( f \"[DRY RUN] Would inject disk { operation } : { size_mb } MB\" ) INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"skipped\" ) . inc () return print ( f \"[DISK] Injecting { operation } : { size_mb } MB...\" ) INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 1 ) try : # Implement disk chaos here # Example: dd if=/dev/zero of=/tmp/fill bs=1M count=size_mb INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"success\" ) . inc () except Exception as e : INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"failed\" ) . inc () print ( f \"[DISK] Failed: { e } \" ) finally : INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 0 ) 2. Register in agent.py # src/agent.py FAILURE_MODULES = { \"cpu\" : \".failures.cpu\" , \"memory\" : \".failures.memory\" , \"process\" : \".failures.process\" , \"network\" : \".failures.network\" , \"disk\" : \".failures.disk\" , # Add new module } 3. Add configuration section # config.yaml failures : # ... existing failures disk : enabled : true probability : 0.2 operation : \"fill\" # or \"slow\" size_mb : 500 duration_seconds : 10 4. Write tests # tests/test_failures.py class TestDiskFailures : def test_inject_disk_dry_run ( self , capsys ): config = { \"operation\" : \"fill\" , \"size_mb\" : 100 } inject_disk ( config , dry_run = True ) captured = capsys . readouterr () assert \"DRY RUN\" in captured . out assert \"100MB\" in captured . out def test_inject_disk_metrics ( self ): config = { \"operation\" : \"fill\" , \"size_mb\" : 50 } inject_disk ( config , dry_run = True ) assert INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"skipped\" ) . _value . get () == 1 5. Update documentation Add section to docs/configuration.md describing the new failure type. Adding New Configuration Options \u00b6 1. Update config.py dataclasses # src/config.py @dataclass class AgentConfig : interval_seconds : int dry_run : bool max_concurrent_injections : int = 1 # New option 2. Update config loading agent_cfg = AgentConfig ( interval_seconds = raw [ \"agent\" ][ \"interval_seconds\" ], dry_run = raw [ \"agent\" ] . get ( \"dry_run\" , False ), max_concurrent_injections = raw [ \"agent\" ] . get ( \"max_concurrent_injections\" , 1 ), ) 3. Write tests def test_load_config_with_new_option ( self , tmp_path ): config_file = tmp_path / \"config.yaml\" config_file . write_text ( \"\"\" agent: interval_seconds: 10 dry_run: false max_concurrent_injections: 3 failures: cpu: enabled: true probability: 0.5 duration_seconds: 5 cores: 2 \"\"\" ) config = load_config ( str ( config_file )) assert config . agent . max_concurrent_injections == 3 Testing Guidelines \u00b6 Test Organization \u00b6 Unit tests : Test individual functions in isolation Integration tests : Test multiple components together Parametrized tests : Test multiple inputs efficiently Writing Good Tests \u00b6 # Good: Clear test name, single responsibility def test_inject_cpu_with_multiple_cores ( self ): config = { \"duration_seconds\" : 1 , \"cores\" : 2 } inject_cpu ( config , dry_run = False ) # Assert expected behavior # Bad: Unclear name, testing multiple things def test_cpu ( self ): config = {} inject_cpu ( config , True ) inject_cpu ( config , False ) # Multiple assertions Test Fixtures \u00b6 # conftest.py import pytest @pytest . fixture def sample_config (): \"\"\"Provide a standard test configuration.\"\"\" return { \"duration_seconds\" : 1 , \"cores\" : 1 , \"probability\" : 0.5 } # Use in tests def test_with_fixture ( self , sample_config ): inject_cpu ( sample_config , dry_run = True ) Mocking External Dependencies \u00b6 from unittest.mock import patch , MagicMock @patch ( 'src.failures.network._run_cmd' ) def test_network_injection ( self , mock_run_cmd ): # Control external command behavior mock_run_cmd . return_value = MagicMock ( returncode = 0 ) config = { \"interface\" : \"eth0\" , \"delay_ms\" : 100 , \"duration_seconds\" : 1 } inject_network ( config , dry_run = False ) # Verify command was called correctly mock_run_cmd . assert_called () Code Style Guide \u00b6 Python Style \u00b6 Follow PEP 8 with these specifics: Line length: 100 characters (configured in .flake8) Use type hints where appropriate Docstrings for public functions Descriptive variable names # Good def inject_cpu ( config : dict , dry_run : bool = False ) -> None : \"\"\" Inject CPU stress by spawning worker processes. Args: config: Configuration dictionary with 'cores' and 'duration_seconds' dry_run: If True, log actions without executing \"\"\" cores = config . get ( \"cores\" , 1 ) duration = config [ \"duration_seconds\" ] # ... # Bad def inject ( c , d = False ): n = c . get ( \"cores\" , 1 ) t = c [ \"duration_seconds\" ] # ... Commit Messages \u00b6 Follow conventional commits: # Good commits git commit -m \"feat: add disk I/O failure injection\" git commit -m \"fix: prevent self-termination in process killer\" git commit -m \"docs: update configuration reference\" git commit -m \"test: add tests for network cleanup\" git commit -m \"refactor: extract common injection logic\" # Bad commits git commit -m \"updates\" git commit -m \"fix bug\" git commit -m \"WIP\" Branch Naming \u00b6 # Feature branches git checkout -b feature/disk-io-chaos # Bug fixes git checkout -b fix/memory-leak-in-injector # Documentation git checkout -b docs/add-examples # Refactoring git checkout -b refactor/simplify-config-loading Debugging Tips \u00b6 Common Issues \u00b6 1. Import errors # Ensure you're running from project root python -m src.agent # Not: python src/agent.py (breaks relative imports) 2. Metrics not updating # Verify metrics are registered from src.metrics import INJECTIONS_TOTAL print ( INJECTIONS_TOTAL . _metrics ) # Check if labels match INJECTIONS_TOTAL . labels ( failure_type = \"cpu\" , status = \"success\" ) . inc () 3. Tests failing inconsistently # Reset metrics between tests (should be in conftest.py) @pytest . fixture ( autouse = True ) def reset_metrics (): INJECTIONS_TOTAL . _metrics . clear () INJECTION_ACTIVE . _metrics . clear () yield 4. Docker networking issues # Inspect network docker network ls docker network inspect py-chaos-agent_default # Check if containers can reach each other docker exec chaos-agent ping target-app Logging \u00b6 Add debug logging for development: import logging logging . basicConfig ( level = logging . DEBUG ) logger = logging . getLogger ( __name__ ) def inject_cpu ( config : dict , dry_run : bool = False ): logger . debug ( f \"CPU injection called with config: { config } \" ) # ... Performance Profiling \u00b6 # Profile CPU usage python -m cProfile -o profile.stats -m src.agent # Analyze results python -c \"import pstats; p = pstats.Stats('profile.stats'); p.sort_stats('cumtime'); p.print_stats(20)\" # Memory profiling pip install memory_profiler python -m memory_profiler src/agent.py CI/CD Pipeline \u00b6 GitHub Actions Workflow \u00b6 The .github/workflows/ci.yml runs: Lint : Black, flake8, mypy Test : pytest with coverage Coverage report : Uploaded to codecov (optional) Running CI Locally \u00b6 # Install act (GitHub Actions locally) # https://github.com/nektos/act # Run the CI workflow act -j test Pre-commit Hooks \u00b6 # Install pre-commit pip install pre-commit # Create .pre-commit-config.yaml cat > .pre-commit-config.yaml <<EOF repos: - repo: https://github.com/psf/black rev: 23.12.1 hooks: - id: black - repo: https://github.com/pycqa/flake8 rev: 7.0.0 hooks: - id: flake8 - repo: https://github.com/pre-commit/mirrors-mypy rev: v1.8.0 hooks: - id: mypy additional_dependencies: [types-PyYAML] EOF # Install hooks pre-commit install # Now black, flake8, mypy run automatically on commit Contributing \u00b6 Pull Request Process \u00b6 Fork and clone the repository Create feature branch from main Make changes following code style guide Add tests for new functionality Run test suite and ensure all pass Update documentation if needed Submit pull request with clear description Pull Request Template \u00b6 ## Description Brief description of changes ## Type of Change - [ ] Bug fix - [ ] New feature - [ ] Breaking change - [ ] Documentation update ## Testing - [ ] Added unit tests - [ ] Added integration tests - [ ] All tests pass locally ## Checklist - [ ] Code follows style guidelines - [ ] Self-review completed - [ ] Comments added for complex logic - [ ] Documentation updated - [ ] No new warnings generated Release Process \u00b6 Update version in setup.py (if exists) or release notes Update CHANGELOG.md with changes Create git tag : git tag -a v1.0.0 -m \"Release version 1.0.0\" git push origin v1.0.0 Build Docker images with version tag Create GitHub release with release notes Resources \u00b6 Python Tools \u00b6 Black Documentation flake8 Documentation mypy Documentation pytest Documentation Docker \u00b6 Docker Best Practices Docker Compose Documentation Kubernetes \u00b6 Kubernetes Documentation kubectl Cheat Sheet Getting Help \u00b6 Issues : Open GitHub issues for bugs or feature requests Discussions : Use GitHub discussions for questions Documentation : Check docs/ folder for detailed guides Examples : See examples/ folder for use cases","title":"Contributing"},{"location":"development/development/#getting-started","text":"","title":"Getting Started"},{"location":"development/development/#prerequisites","text":"Python 3.10 or higher Docker and Docker Compose Git Virtual environment tool (venv, virtualenv, or conda)","title":"Prerequisites"},{"location":"development/development/#initial-setup","text":"# Clone the repository git clone https://github.com/yourusername/py-chaos-agent.git cd py-chaos-agent # Create virtual environment python -m venv venv # Activate virtual environment source venv/bin/activate # On Linux/Mac # or venv \\S cripts \\a ctivate # On Windows # Install dependencies pip install -r requirements.txt -r requirements-dev.txt # Verify installation python -c \"import psutil, yaml, prometheus_client; print('Dependencies OK')\"","title":"Initial Setup"},{"location":"development/development/#project-structure","text":"py-chaos-agent/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 agent.py # Main agent loop \u2502 \u251c\u2500\u2500 config.py # Configuration loading \u2502 \u251c\u2500\u2500 metrics.py # Prometheus metrics \u2502 \u2514\u2500\u2500 failures/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 cpu.py # CPU stress injection \u2502 \u251c\u2500\u2500 memory.py # Memory pressure injection \u2502 \u251c\u2500\u2500 process.py # Process termination \u2502 \u2514\u2500\u2500 network.py # Network latency injection \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 conftest.py # Test fixtures \u2502 \u251c\u2500\u2500 test_config.py # Configuration tests \u2502 \u251c\u2500\u2500 test_failures.py # Failure module tests \u2502 \u251c\u2500\u2500 test_integration.py # Integration tests \u2502 \u2514\u2500\u2500 test_metrics.py # Metrics tests \u251c\u2500\u2500 docker/ \u2502 \u251c\u2500\u2500 Dockerfile # Chaos agent image \u2502 \u251c\u2500\u2500 Dockerfile.target # Target app image \u2502 \u2514\u2500\u2500 target-app.py # Simple test application \u251c\u2500\u2500 k8s/ \u2502 \u2514\u2500\u2500 chaos-demo.yaml # Kubernetes manifests \u251c\u2500\u2500 terraform/ \u2502 \u2514\u2500\u2500 *.tf # Infrastructure as code \u251c\u2500\u2500 docs/ \u2502 \u2514\u2500\u2500 *.md # Documentation \u251c\u2500\u2500 config.yaml # Default configuration \u251c\u2500\u2500 docker-compose.yml # Local development setup \u251c\u2500\u2500 requirements.txt # Runtime dependencies \u251c\u2500\u2500 requirements-dev.txt # Development dependencies \u2514\u2500\u2500 README.md","title":"Project Structure"},{"location":"development/development/#development-workflow","text":"","title":"Development Workflow"},{"location":"development/development/#running-tests","text":"# Run all tests pytest # Run with verbose output pytest -v # Run specific test file pytest tests/test_failures.py # Run specific test function pytest tests/test_failures.py::TestCPUFailures::test_inject_cpu_dry_run # Run with coverage report pytest --cov = src --cov-report = term-missing # Generate HTML coverage report pytest --cov = src --cov-report = html # Open htmlcov/index.html in browser # Run only fast tests (skip slow/integration tests) pytest -m \"not slow\"","title":"Running Tests"},{"location":"development/development/#code-quality","text":"# Format code with Black black src tests # Check code style with flake8 flake8 src tests # Type checking with mypy mypy src # Run all quality checks (what CI runs) black --check src tests flake8 src tests mypy src --install-types --non-interactive","title":"Code Quality"},{"location":"development/development/#local-testing","text":"# Test with dry-run mode python -m src.agent # Run with Docker Compose docker-compose up --build # View logs docker-compose logs -f chaos-agent # Stop containers docker-compose down","title":"Local Testing"},{"location":"development/development/#debugging","text":"# Run agent with Python debugger python -m pdb -m src.agent # Or use breakpoints in code import pdb ; pdb.set_trace () # Debug in container docker-compose run --rm chaos-agent /bin/bash","title":"Debugging"},{"location":"development/development/#adding-new-features","text":"","title":"Adding New Features"},{"location":"development/development/#adding-a-new-failure-type","text":"1. Create the module # src/failures/disk.py from ..metrics import INJECTIONS_TOTAL , INJECTION_ACTIVE def inject_disk ( config : dict , dry_run : bool = False ): \"\"\"Inject disk I/O chaos.\"\"\" operation = config . get ( \"operation\" , \"fill\" ) size_mb = config . get ( \"size_mb\" , 100 ) if dry_run : print ( f \"[DRY RUN] Would inject disk { operation } : { size_mb } MB\" ) INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"skipped\" ) . inc () return print ( f \"[DISK] Injecting { operation } : { size_mb } MB...\" ) INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 1 ) try : # Implement disk chaos here # Example: dd if=/dev/zero of=/tmp/fill bs=1M count=size_mb INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"success\" ) . inc () except Exception as e : INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"failed\" ) . inc () print ( f \"[DISK] Failed: { e } \" ) finally : INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 0 ) 2. Register in agent.py # src/agent.py FAILURE_MODULES = { \"cpu\" : \".failures.cpu\" , \"memory\" : \".failures.memory\" , \"process\" : \".failures.process\" , \"network\" : \".failures.network\" , \"disk\" : \".failures.disk\" , # Add new module } 3. Add configuration section # config.yaml failures : # ... existing failures disk : enabled : true probability : 0.2 operation : \"fill\" # or \"slow\" size_mb : 500 duration_seconds : 10 4. Write tests # tests/test_failures.py class TestDiskFailures : def test_inject_disk_dry_run ( self , capsys ): config = { \"operation\" : \"fill\" , \"size_mb\" : 100 } inject_disk ( config , dry_run = True ) captured = capsys . readouterr () assert \"DRY RUN\" in captured . out assert \"100MB\" in captured . out def test_inject_disk_metrics ( self ): config = { \"operation\" : \"fill\" , \"size_mb\" : 50 } inject_disk ( config , dry_run = True ) assert INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"skipped\" ) . _value . get () == 1 5. Update documentation Add section to docs/configuration.md describing the new failure type.","title":"Adding a New Failure Type"},{"location":"development/development/#adding-new-configuration-options","text":"1. Update config.py dataclasses # src/config.py @dataclass class AgentConfig : interval_seconds : int dry_run : bool max_concurrent_injections : int = 1 # New option 2. Update config loading agent_cfg = AgentConfig ( interval_seconds = raw [ \"agent\" ][ \"interval_seconds\" ], dry_run = raw [ \"agent\" ] . get ( \"dry_run\" , False ), max_concurrent_injections = raw [ \"agent\" ] . get ( \"max_concurrent_injections\" , 1 ), ) 3. Write tests def test_load_config_with_new_option ( self , tmp_path ): config_file = tmp_path / \"config.yaml\" config_file . write_text ( \"\"\" agent: interval_seconds: 10 dry_run: false max_concurrent_injections: 3 failures: cpu: enabled: true probability: 0.5 duration_seconds: 5 cores: 2 \"\"\" ) config = load_config ( str ( config_file )) assert config . agent . max_concurrent_injections == 3","title":"Adding New Configuration Options"},{"location":"development/development/#testing-guidelines","text":"","title":"Testing Guidelines"},{"location":"development/development/#test-organization","text":"Unit tests : Test individual functions in isolation Integration tests : Test multiple components together Parametrized tests : Test multiple inputs efficiently","title":"Test Organization"},{"location":"development/development/#writing-good-tests","text":"# Good: Clear test name, single responsibility def test_inject_cpu_with_multiple_cores ( self ): config = { \"duration_seconds\" : 1 , \"cores\" : 2 } inject_cpu ( config , dry_run = False ) # Assert expected behavior # Bad: Unclear name, testing multiple things def test_cpu ( self ): config = {} inject_cpu ( config , True ) inject_cpu ( config , False ) # Multiple assertions","title":"Writing Good Tests"},{"location":"development/development/#test-fixtures","text":"# conftest.py import pytest @pytest . fixture def sample_config (): \"\"\"Provide a standard test configuration.\"\"\" return { \"duration_seconds\" : 1 , \"cores\" : 1 , \"probability\" : 0.5 } # Use in tests def test_with_fixture ( self , sample_config ): inject_cpu ( sample_config , dry_run = True )","title":"Test Fixtures"},{"location":"development/development/#mocking-external-dependencies","text":"from unittest.mock import patch , MagicMock @patch ( 'src.failures.network._run_cmd' ) def test_network_injection ( self , mock_run_cmd ): # Control external command behavior mock_run_cmd . return_value = MagicMock ( returncode = 0 ) config = { \"interface\" : \"eth0\" , \"delay_ms\" : 100 , \"duration_seconds\" : 1 } inject_network ( config , dry_run = False ) # Verify command was called correctly mock_run_cmd . assert_called ()","title":"Mocking External Dependencies"},{"location":"development/development/#code-style-guide","text":"","title":"Code Style Guide"},{"location":"development/development/#python-style","text":"Follow PEP 8 with these specifics: Line length: 100 characters (configured in .flake8) Use type hints where appropriate Docstrings for public functions Descriptive variable names # Good def inject_cpu ( config : dict , dry_run : bool = False ) -> None : \"\"\" Inject CPU stress by spawning worker processes. Args: config: Configuration dictionary with 'cores' and 'duration_seconds' dry_run: If True, log actions without executing \"\"\" cores = config . get ( \"cores\" , 1 ) duration = config [ \"duration_seconds\" ] # ... # Bad def inject ( c , d = False ): n = c . get ( \"cores\" , 1 ) t = c [ \"duration_seconds\" ] # ...","title":"Python Style"},{"location":"development/development/#commit-messages","text":"Follow conventional commits: # Good commits git commit -m \"feat: add disk I/O failure injection\" git commit -m \"fix: prevent self-termination in process killer\" git commit -m \"docs: update configuration reference\" git commit -m \"test: add tests for network cleanup\" git commit -m \"refactor: extract common injection logic\" # Bad commits git commit -m \"updates\" git commit -m \"fix bug\" git commit -m \"WIP\"","title":"Commit Messages"},{"location":"development/development/#branch-naming","text":"# Feature branches git checkout -b feature/disk-io-chaos # Bug fixes git checkout -b fix/memory-leak-in-injector # Documentation git checkout -b docs/add-examples # Refactoring git checkout -b refactor/simplify-config-loading","title":"Branch Naming"},{"location":"development/development/#debugging-tips","text":"","title":"Debugging Tips"},{"location":"development/development/#common-issues","text":"1. Import errors # Ensure you're running from project root python -m src.agent # Not: python src/agent.py (breaks relative imports) 2. Metrics not updating # Verify metrics are registered from src.metrics import INJECTIONS_TOTAL print ( INJECTIONS_TOTAL . _metrics ) # Check if labels match INJECTIONS_TOTAL . labels ( failure_type = \"cpu\" , status = \"success\" ) . inc () 3. Tests failing inconsistently # Reset metrics between tests (should be in conftest.py) @pytest . fixture ( autouse = True ) def reset_metrics (): INJECTIONS_TOTAL . _metrics . clear () INJECTION_ACTIVE . _metrics . clear () yield 4. Docker networking issues # Inspect network docker network ls docker network inspect py-chaos-agent_default # Check if containers can reach each other docker exec chaos-agent ping target-app","title":"Common Issues"},{"location":"development/development/#logging","text":"Add debug logging for development: import logging logging . basicConfig ( level = logging . DEBUG ) logger = logging . getLogger ( __name__ ) def inject_cpu ( config : dict , dry_run : bool = False ): logger . debug ( f \"CPU injection called with config: { config } \" ) # ...","title":"Logging"},{"location":"development/development/#performance-profiling","text":"# Profile CPU usage python -m cProfile -o profile.stats -m src.agent # Analyze results python -c \"import pstats; p = pstats.Stats('profile.stats'); p.sort_stats('cumtime'); p.print_stats(20)\" # Memory profiling pip install memory_profiler python -m memory_profiler src/agent.py","title":"Performance Profiling"},{"location":"development/development/#cicd-pipeline","text":"","title":"CI/CD Pipeline"},{"location":"development/development/#github-actions-workflow","text":"The .github/workflows/ci.yml runs: Lint : Black, flake8, mypy Test : pytest with coverage Coverage report : Uploaded to codecov (optional)","title":"GitHub Actions Workflow"},{"location":"development/development/#running-ci-locally","text":"# Install act (GitHub Actions locally) # https://github.com/nektos/act # Run the CI workflow act -j test","title":"Running CI Locally"},{"location":"development/development/#pre-commit-hooks","text":"# Install pre-commit pip install pre-commit # Create .pre-commit-config.yaml cat > .pre-commit-config.yaml <<EOF repos: - repo: https://github.com/psf/black rev: 23.12.1 hooks: - id: black - repo: https://github.com/pycqa/flake8 rev: 7.0.0 hooks: - id: flake8 - repo: https://github.com/pre-commit/mirrors-mypy rev: v1.8.0 hooks: - id: mypy additional_dependencies: [types-PyYAML] EOF # Install hooks pre-commit install # Now black, flake8, mypy run automatically on commit","title":"Pre-commit Hooks"},{"location":"development/development/#contributing","text":"","title":"Contributing"},{"location":"development/development/#pull-request-process","text":"Fork and clone the repository Create feature branch from main Make changes following code style guide Add tests for new functionality Run test suite and ensure all pass Update documentation if needed Submit pull request with clear description","title":"Pull Request Process"},{"location":"development/development/#pull-request-template","text":"## Description Brief description of changes ## Type of Change - [ ] Bug fix - [ ] New feature - [ ] Breaking change - [ ] Documentation update ## Testing - [ ] Added unit tests - [ ] Added integration tests - [ ] All tests pass locally ## Checklist - [ ] Code follows style guidelines - [ ] Self-review completed - [ ] Comments added for complex logic - [ ] Documentation updated - [ ] No new warnings generated","title":"Pull Request Template"},{"location":"development/development/#release-process","text":"Update version in setup.py (if exists) or release notes Update CHANGELOG.md with changes Create git tag : git tag -a v1.0.0 -m \"Release version 1.0.0\" git push origin v1.0.0 Build Docker images with version tag Create GitHub release with release notes","title":"Release Process"},{"location":"development/development/#resources","text":"","title":"Resources"},{"location":"development/development/#python-tools","text":"Black Documentation flake8 Documentation mypy Documentation pytest Documentation","title":"Python Tools"},{"location":"development/development/#docker","text":"Docker Best Practices Docker Compose Documentation","title":"Docker"},{"location":"development/development/#kubernetes","text":"Kubernetes Documentation kubectl Cheat Sheet","title":"Kubernetes"},{"location":"development/development/#getting-help","text":"Issues : Open GitHub issues for bugs or feature requests Discussions : Use GitHub discussions for questions Documentation : Check docs/ folder for detailed guides Examples : See examples/ folder for use cases","title":"Getting Help"},{"location":"getting-started/configuration/","text":"Overview \u00b6 Py-Chaos-Agent is configured via a YAML file that defines agent behavior and failure injection parameters. The default configuration file is config.yaml in the application root. Configuration Structure \u00b6 agent : # Agent-level settings failures : # Individual failure type configurations Agent Configuration \u00b6 agent.interval_seconds \u00b6 Type: Integer Default: None (required) Description: How often (in seconds) the agent checks for potential chaos injections. agent : interval_seconds : 10 # Check every 10 seconds Lower values increase chaos frequency but consume more resources. Recommended range: 5-60 seconds. agent.dry_run \u00b6 Type: Boolean Default: false Description: When true , the agent logs what it would do without executing actual chaos. agent : dry_run : true # Test configuration without actual chaos Use cases: Testing configuration changes Validating probability settings Demonstrating chaos behavior safely Failure Configurations \u00b6 All failure types share common parameters: Common Parameters \u00b6 enabled \u00b6 Type: Boolean Required: Yes Description: Whether this failure type is active. failures : cpu : enabled : false # Disable CPU chaos probability \u00b6 Type: Float (0.0 - 1.0) Required: Yes Description: Chance of injection occurring each interval. failures : cpu : probability : 0.3 # 30% chance per check Guidelines: Start with low probabilities (0.1-0.3) for testing Higher probabilities create more aggressive chaos Probability of 1.0 means inject every interval Probability of 0.0 effectively disables the failure duration_seconds \u00b6 Type: Integer Required: For CPU, Memory, Network Description: How long the chaos effect lasts. failures : cpu : duration_seconds : 5 # Hog CPU for 5 seconds CPU Failure \u00b6 Spawns processes that consume CPU cycles. Configuration \u00b6 failures : cpu : enabled : true probability : 0.3 duration_seconds : 5 cores : 2 Parameters \u00b6 cores \u00b6 Type: Integer Default: 1 Description: Number of CPU cores to stress simultaneously. Examples: cores : 1 # Light CPU stress cores : 2 # Moderate CPU stress cores : 4 # Heavy CPU stress Considerations: Setting cores higher than available CPU can cause severe performance degradation Use dry-run to verify impact before production testing CPU stress blocks during execution; avoid very long durations Example Scenarios \u00b6 Light, frequent CPU spikes: cpu : enabled : true probability : 0.5 duration_seconds : 3 cores : 1 Heavy, rare CPU stress: cpu : enabled : true probability : 0.1 duration_seconds : 30 cores : 4 Memory Failure \u00b6 Allocates and holds memory for a specified duration. Configuration \u00b6 failures : memory : enabled : true probability : 0.2 duration_seconds : 10 mb : 200 Parameters \u00b6 mb \u00b6 Type: Integer Default: 100 Description: Amount of memory to allocate in megabytes. Examples: mb : 50 # Light memory pressure mb : 200 # Moderate memory pressure mb : 1024 # Heavy memory pressure (1GB) Considerations: Memory injection runs in a background thread Allocated memory is filled with data to prevent OS optimization Setting mb higher than available memory may cause OOM kills The chaos agent itself requires memory; account for this Example Scenarios \u00b6 Gradual memory pressure: memory : enabled : true probability : 0.4 duration_seconds : 15 mb : 100 Sudden memory spike: memory : enabled : true probability : 0.1 duration_seconds : 5 mb : 500 Process Failure \u00b6 Terminates target processes by name or command line. Configuration \u00b6 failures : process : enabled : true probability : 0.3 target_name : \"target-app\" Parameters \u00b6 target_name \u00b6 Type: String Required: Yes Description: Name or substring to match against process names or command lines. Examples: target_name : \"my_app\" # Kills my_app process target_name : \"api_server\" # Kill API servere target_name : \"target-app\" # Kill specific app Matching behavior: Case-insensitive substring matching Matches against process name (e.g., python3 ) Also matches against command line arguments First matching process is terminated Safety mechanisms: Chaos agent never kills itself Protected PIDs: agent process, parent, and all children Processes with \"chaos\" or \"agent.py\" in command line are excluded Termination Process \u00b6 Send SIGTERM (graceful shutdown) Wait up to 3 seconds for termination If still running, send SIGKILL (forced termination) Wait up to 2 seconds for confirmation Security Considerations \u00b6 Target Name Safety: - \u2705 Use specific application names: \"myapp\" , \"api-server\" , \"worker-service\" - \u274c Avoid generic names: \"python\" , \"java\" , \"node\" (will be rejected) - Minimum 3 characters required for safety Protected Processes: The chaos agent will never kill: - System critical processes (systemd, init) - Container infrastructure (dockerd, containerd, kubelet) - Network services (sshd, NetworkManager) - The chaos agent itself and its children Example Scenarios \u00b6 High availability testing: process : enabled : true probability : 0.5 target_name : \"api-server\" Rare catastrophic failure: process : enabled : true probability : 0.05 target_name : \"database\" Network Failure \u00b6 Injects network latency using Linux traffic control (tc). Configuration \u00b6 failures : network : enabled : true probability : 0.25 duration_seconds : 10 interface : \"eth0\" delay_ms : 300 Parameters \u00b6 interface \u00b6 Type: String Default: \"eth0\" Description: Network interface to apply latency to. Common values: eth0 - Primary Ethernet interface wlan0 - Wireless interface lo - Loopback (for testing) Finding your interface: # Inside the container ip addr show # Or ifconfig delay_ms \u00b6 Type: Integer Default: 100 Description: Network latency to add in milliseconds. Examples: delay_ms : 50 # Slight delay (good connection) delay_ms : 200 # Noticeable delay (poor connection) delay_ms : 1000 # Severe delay (1 second) Real-world equivalents: 10-50ms: Local network 50-150ms: Cross-country 150-300ms: Intercontinental 300+ms: Satellite connection Requirements \u00b6 Kubernetes: securityContext : capabilities : add : [ \"NET_ADMIN\" ] Docker: privileged : true # Or add NET_ADMIN capability Cleanup \u00b6 Network rules are automatically cleaned up: On agent shutdown (SIGTERM/SIGINT) Before each new network injection On startup (removes any leftover rules) Example Scenarios \u00b6 Intermittent latency spikes: network : enabled : true probability : 0.3 duration_seconds : 5 delay_ms : 200 interface : \"eth0\" Sustained poor connectivity: network : enabled : true probability : 0.6 duration_seconds : 30 delay_ms : 500 interface : \"eth0\" Complete Configuration Examples \u00b6 Conservative Testing \u00b6 For initial resilience testing in non-critical environments: agent : interval_seconds : 30 dry_run : false failures : cpu : enabled : true probability : 0.2 duration_seconds : 5 cores : 1 memory : enabled : true probability : 0.15 duration_seconds : 8 mb : 100 process : enabled : false # Disabled for initial testing network : enabled : true probability : 0.2 duration_seconds : 10 interface : \"eth0\" delay_ms : 150 Aggressive Testing \u00b6 For chaos engineering in robust test environments: agent : interval_seconds : 10 dry_run : false failures : cpu : enabled : true probability : 0.5 duration_seconds : 8 cores : 2 memory : enabled : true probability : 0.4 duration_seconds : 12 mb : 300 process : enabled : true probability : 0.3 target_name : \"target-app\" network : enabled : true probability : 0.4 duration_seconds : 15 interface : \"eth0\" delay_ms : 400 Process-Only Testing \u00b6 For testing application restart and recovery: agent : interval_seconds : 20 dry_run : false failures : cpu : enabled : false memory : enabled : false process : enabled : true probability : 0.8 target_name : \"myapp\" network : enabled : false Network-Only Testing \u00b6 For testing distributed system behavior under latency: agent : interval_seconds : 15 dry_run : false failures : cpu : enabled : false memory : enabled : false process : enabled : false network : enabled : true probability : 0.6 duration_seconds : 20 interface : \"eth0\" delay_ms : 300 Configuration in Kubernetes \u00b6 Using ConfigMaps \u00b6 apiVersion : v1 kind : ConfigMap metadata : name : chaos-config data : config.yaml : | agent: interval_seconds: 15 dry_run: false failures: # ... your configuration Mount as volume: volumes : - name : config configMap : name : chaos-config volumeMounts : - name : config mountPath : /app/config.yaml subPath : config.yaml Dynamic Updates \u00b6 To update configuration without restarting pods: # Edit ConfigMap kubectl edit configmap chaos-config -n chaos-demo # Delete pod to pick up new config kubectl delete pod -n chaos-demo -l app = resilient-app Best Practices \u00b6 Start with dry-run: Always test configuration with dry_run: true first Gradual probability increase: Begin with low probabilities (0.1-0.2) and increase gradually Monitor during testing: Watch metrics and application logs during chaos experiments Document baselines: Record normal system behavior before introducing chaos Single failure type: Test one failure type at a time initially Reasonable durations: Keep durations short (5-15 seconds) for most scenarios Consider dependencies: Account for application startup time when configuring process kills Network interface verification: Confirm correct interface name before network testing Resource awareness: Don't allocate more resources than available (especially memory) Version control: Keep configurations in git with descriptive commit messages Troubleshooting \u00b6 Configuration not loading \u00b6 # Verify YAML syntax python -c \"import yaml; yaml.safe_load(open('config.yaml'))\" # Check file permissions ls -l config.yaml # Verify mount in Kubernetes kubectl exec -it <pod-name> -c chaos-agent -- cat /app/config.yaml Chaos not triggering \u00b6 Check enabled: true for desired failure types Verify probability is > 0 Confirm dry_run is false Check agent logs for error messages Verify required capabilities (NET_ADMIN for network) Unexpected behavior \u00b6 Review probability calculations (multiply probability \u00d7 checks per minute) Confirm durations aren't overlapping Check for resource constraints on chaos agent pod Verify target names match actual processes","title":"Configuration"},{"location":"getting-started/configuration/#overview","text":"Py-Chaos-Agent is configured via a YAML file that defines agent behavior and failure injection parameters. The default configuration file is config.yaml in the application root.","title":"Overview"},{"location":"getting-started/configuration/#configuration-structure","text":"agent : # Agent-level settings failures : # Individual failure type configurations","title":"Configuration Structure"},{"location":"getting-started/configuration/#agent-configuration","text":"","title":"Agent Configuration"},{"location":"getting-started/configuration/#agentinterval_seconds","text":"Type: Integer Default: None (required) Description: How often (in seconds) the agent checks for potential chaos injections. agent : interval_seconds : 10 # Check every 10 seconds Lower values increase chaos frequency but consume more resources. Recommended range: 5-60 seconds.","title":"agent.interval_seconds"},{"location":"getting-started/configuration/#agentdry_run","text":"Type: Boolean Default: false Description: When true , the agent logs what it would do without executing actual chaos. agent : dry_run : true # Test configuration without actual chaos Use cases: Testing configuration changes Validating probability settings Demonstrating chaos behavior safely","title":"agent.dry_run"},{"location":"getting-started/configuration/#failure-configurations","text":"All failure types share common parameters:","title":"Failure Configurations"},{"location":"getting-started/configuration/#common-parameters","text":"","title":"Common Parameters"},{"location":"getting-started/configuration/#enabled","text":"Type: Boolean Required: Yes Description: Whether this failure type is active. failures : cpu : enabled : false # Disable CPU chaos","title":"enabled"},{"location":"getting-started/configuration/#probability","text":"Type: Float (0.0 - 1.0) Required: Yes Description: Chance of injection occurring each interval. failures : cpu : probability : 0.3 # 30% chance per check Guidelines: Start with low probabilities (0.1-0.3) for testing Higher probabilities create more aggressive chaos Probability of 1.0 means inject every interval Probability of 0.0 effectively disables the failure","title":"probability"},{"location":"getting-started/configuration/#duration_seconds","text":"Type: Integer Required: For CPU, Memory, Network Description: How long the chaos effect lasts. failures : cpu : duration_seconds : 5 # Hog CPU for 5 seconds","title":"duration_seconds"},{"location":"getting-started/configuration/#cpu-failure","text":"Spawns processes that consume CPU cycles.","title":"CPU Failure"},{"location":"getting-started/configuration/#configuration","text":"failures : cpu : enabled : true probability : 0.3 duration_seconds : 5 cores : 2","title":"Configuration"},{"location":"getting-started/configuration/#parameters","text":"","title":"Parameters"},{"location":"getting-started/configuration/#cores","text":"Type: Integer Default: 1 Description: Number of CPU cores to stress simultaneously. Examples: cores : 1 # Light CPU stress cores : 2 # Moderate CPU stress cores : 4 # Heavy CPU stress Considerations: Setting cores higher than available CPU can cause severe performance degradation Use dry-run to verify impact before production testing CPU stress blocks during execution; avoid very long durations","title":"cores"},{"location":"getting-started/configuration/#example-scenarios","text":"Light, frequent CPU spikes: cpu : enabled : true probability : 0.5 duration_seconds : 3 cores : 1 Heavy, rare CPU stress: cpu : enabled : true probability : 0.1 duration_seconds : 30 cores : 4","title":"Example Scenarios"},{"location":"getting-started/configuration/#memory-failure","text":"Allocates and holds memory for a specified duration.","title":"Memory Failure"},{"location":"getting-started/configuration/#configuration_1","text":"failures : memory : enabled : true probability : 0.2 duration_seconds : 10 mb : 200","title":"Configuration"},{"location":"getting-started/configuration/#parameters_1","text":"","title":"Parameters"},{"location":"getting-started/configuration/#mb","text":"Type: Integer Default: 100 Description: Amount of memory to allocate in megabytes. Examples: mb : 50 # Light memory pressure mb : 200 # Moderate memory pressure mb : 1024 # Heavy memory pressure (1GB) Considerations: Memory injection runs in a background thread Allocated memory is filled with data to prevent OS optimization Setting mb higher than available memory may cause OOM kills The chaos agent itself requires memory; account for this","title":"mb"},{"location":"getting-started/configuration/#example-scenarios_1","text":"Gradual memory pressure: memory : enabled : true probability : 0.4 duration_seconds : 15 mb : 100 Sudden memory spike: memory : enabled : true probability : 0.1 duration_seconds : 5 mb : 500","title":"Example Scenarios"},{"location":"getting-started/configuration/#process-failure","text":"Terminates target processes by name or command line.","title":"Process Failure"},{"location":"getting-started/configuration/#configuration_2","text":"failures : process : enabled : true probability : 0.3 target_name : \"target-app\"","title":"Configuration"},{"location":"getting-started/configuration/#parameters_2","text":"","title":"Parameters"},{"location":"getting-started/configuration/#target_name","text":"Type: String Required: Yes Description: Name or substring to match against process names or command lines. Examples: target_name : \"my_app\" # Kills my_app process target_name : \"api_server\" # Kill API servere target_name : \"target-app\" # Kill specific app Matching behavior: Case-insensitive substring matching Matches against process name (e.g., python3 ) Also matches against command line arguments First matching process is terminated Safety mechanisms: Chaos agent never kills itself Protected PIDs: agent process, parent, and all children Processes with \"chaos\" or \"agent.py\" in command line are excluded","title":"target_name"},{"location":"getting-started/configuration/#termination-process","text":"Send SIGTERM (graceful shutdown) Wait up to 3 seconds for termination If still running, send SIGKILL (forced termination) Wait up to 2 seconds for confirmation","title":"Termination Process"},{"location":"getting-started/configuration/#security-considerations","text":"Target Name Safety: - \u2705 Use specific application names: \"myapp\" , \"api-server\" , \"worker-service\" - \u274c Avoid generic names: \"python\" , \"java\" , \"node\" (will be rejected) - Minimum 3 characters required for safety Protected Processes: The chaos agent will never kill: - System critical processes (systemd, init) - Container infrastructure (dockerd, containerd, kubelet) - Network services (sshd, NetworkManager) - The chaos agent itself and its children","title":"Security Considerations"},{"location":"getting-started/configuration/#example-scenarios_2","text":"High availability testing: process : enabled : true probability : 0.5 target_name : \"api-server\" Rare catastrophic failure: process : enabled : true probability : 0.05 target_name : \"database\"","title":"Example Scenarios"},{"location":"getting-started/configuration/#network-failure","text":"Injects network latency using Linux traffic control (tc).","title":"Network Failure"},{"location":"getting-started/configuration/#configuration_3","text":"failures : network : enabled : true probability : 0.25 duration_seconds : 10 interface : \"eth0\" delay_ms : 300","title":"Configuration"},{"location":"getting-started/configuration/#parameters_3","text":"","title":"Parameters"},{"location":"getting-started/configuration/#interface","text":"Type: String Default: \"eth0\" Description: Network interface to apply latency to. Common values: eth0 - Primary Ethernet interface wlan0 - Wireless interface lo - Loopback (for testing) Finding your interface: # Inside the container ip addr show # Or ifconfig","title":"interface"},{"location":"getting-started/configuration/#delay_ms","text":"Type: Integer Default: 100 Description: Network latency to add in milliseconds. Examples: delay_ms : 50 # Slight delay (good connection) delay_ms : 200 # Noticeable delay (poor connection) delay_ms : 1000 # Severe delay (1 second) Real-world equivalents: 10-50ms: Local network 50-150ms: Cross-country 150-300ms: Intercontinental 300+ms: Satellite connection","title":"delay_ms"},{"location":"getting-started/configuration/#requirements","text":"Kubernetes: securityContext : capabilities : add : [ \"NET_ADMIN\" ] Docker: privileged : true # Or add NET_ADMIN capability","title":"Requirements"},{"location":"getting-started/configuration/#cleanup","text":"Network rules are automatically cleaned up: On agent shutdown (SIGTERM/SIGINT) Before each new network injection On startup (removes any leftover rules)","title":"Cleanup"},{"location":"getting-started/configuration/#example-scenarios_3","text":"Intermittent latency spikes: network : enabled : true probability : 0.3 duration_seconds : 5 delay_ms : 200 interface : \"eth0\" Sustained poor connectivity: network : enabled : true probability : 0.6 duration_seconds : 30 delay_ms : 500 interface : \"eth0\"","title":"Example Scenarios"},{"location":"getting-started/configuration/#complete-configuration-examples","text":"","title":"Complete Configuration Examples"},{"location":"getting-started/configuration/#conservative-testing","text":"For initial resilience testing in non-critical environments: agent : interval_seconds : 30 dry_run : false failures : cpu : enabled : true probability : 0.2 duration_seconds : 5 cores : 1 memory : enabled : true probability : 0.15 duration_seconds : 8 mb : 100 process : enabled : false # Disabled for initial testing network : enabled : true probability : 0.2 duration_seconds : 10 interface : \"eth0\" delay_ms : 150","title":"Conservative Testing"},{"location":"getting-started/configuration/#aggressive-testing","text":"For chaos engineering in robust test environments: agent : interval_seconds : 10 dry_run : false failures : cpu : enabled : true probability : 0.5 duration_seconds : 8 cores : 2 memory : enabled : true probability : 0.4 duration_seconds : 12 mb : 300 process : enabled : true probability : 0.3 target_name : \"target-app\" network : enabled : true probability : 0.4 duration_seconds : 15 interface : \"eth0\" delay_ms : 400","title":"Aggressive Testing"},{"location":"getting-started/configuration/#process-only-testing","text":"For testing application restart and recovery: agent : interval_seconds : 20 dry_run : false failures : cpu : enabled : false memory : enabled : false process : enabled : true probability : 0.8 target_name : \"myapp\" network : enabled : false","title":"Process-Only Testing"},{"location":"getting-started/configuration/#network-only-testing","text":"For testing distributed system behavior under latency: agent : interval_seconds : 15 dry_run : false failures : cpu : enabled : false memory : enabled : false process : enabled : false network : enabled : true probability : 0.6 duration_seconds : 20 interface : \"eth0\" delay_ms : 300","title":"Network-Only Testing"},{"location":"getting-started/configuration/#configuration-in-kubernetes","text":"","title":"Configuration in Kubernetes"},{"location":"getting-started/configuration/#using-configmaps","text":"apiVersion : v1 kind : ConfigMap metadata : name : chaos-config data : config.yaml : | agent: interval_seconds: 15 dry_run: false failures: # ... your configuration Mount as volume: volumes : - name : config configMap : name : chaos-config volumeMounts : - name : config mountPath : /app/config.yaml subPath : config.yaml","title":"Using ConfigMaps"},{"location":"getting-started/configuration/#dynamic-updates","text":"To update configuration without restarting pods: # Edit ConfigMap kubectl edit configmap chaos-config -n chaos-demo # Delete pod to pick up new config kubectl delete pod -n chaos-demo -l app = resilient-app","title":"Dynamic Updates"},{"location":"getting-started/configuration/#best-practices","text":"Start with dry-run: Always test configuration with dry_run: true first Gradual probability increase: Begin with low probabilities (0.1-0.2) and increase gradually Monitor during testing: Watch metrics and application logs during chaos experiments Document baselines: Record normal system behavior before introducing chaos Single failure type: Test one failure type at a time initially Reasonable durations: Keep durations short (5-15 seconds) for most scenarios Consider dependencies: Account for application startup time when configuring process kills Network interface verification: Confirm correct interface name before network testing Resource awareness: Don't allocate more resources than available (especially memory) Version control: Keep configurations in git with descriptive commit messages","title":"Best Practices"},{"location":"getting-started/configuration/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"getting-started/configuration/#configuration-not-loading","text":"# Verify YAML syntax python -c \"import yaml; yaml.safe_load(open('config.yaml'))\" # Check file permissions ls -l config.yaml # Verify mount in Kubernetes kubectl exec -it <pod-name> -c chaos-agent -- cat /app/config.yaml","title":"Configuration not loading"},{"location":"getting-started/configuration/#chaos-not-triggering","text":"Check enabled: true for desired failure types Verify probability is > 0 Confirm dry_run is false Check agent logs for error messages Verify required capabilities (NET_ADMIN for network)","title":"Chaos not triggering"},{"location":"getting-started/configuration/#unexpected-behavior","text":"Review probability calculations (multiply probability \u00d7 checks per minute) Confirm durations aren't overlapping Check for resource constraints on chaos agent pod Verify target names match actual processes","title":"Unexpected behavior"},{"location":"getting-started/installation/","text":"This guide covers the different ways to install and run Py-Chaos-Agent. Prerequisites \u00b6 Before installing Py-Chaos-Agent, ensure you have: Python 3.10 or higher Docker (for containerized deployment) kubectl (for Kubernetes deployment) Access to a test environment Docker Installation \u00b6 The recommended way to run Py-Chaos-Agent is using Docker containers. Pull Pre-built Images \u00b6 # Pull the chaos agent image docker pull itsothaimeen/py-chaos-agent:latest # Pull the target app image (for testing) docker pull itsothaimeen/target-app:latest Build from Source \u00b6 # Clone the repository git clone https://github.com/othaime-en/py-chaos-agent.git cd py-chaos-agent # Build the chaos agent image docker build -t py-chaos-agent:latest -f docker/Dockerfile . # Build the target app image docker build -t target-app:latest -f docker/Dockerfile.target . Local Development Installation \u00b6 For local development and testing: # Clone the repository git clone https://github.com/othaime-en/py-chaos-agent.git cd py-chaos-agent # Create a virtual environment python -m venv venv source venv/bin/activate # On Windows: venv\\Scripts\\activate # Install dependencies pip install -r requirements.txt # Install development dependencies (optional) pip install -r requirements-dev.txt Kubernetes Installation \u00b6 For Kubernetes deployment, you'll need: A running Kubernetes cluster (kind, minikube, or cloud-based) kubectl configured to access your cluster # Load images (for local testing with kind/minikube) kind load docker-image py-chaos-agent:latest kind load docker-image target-app:latest # Or for minikube minikube image load py-chaos-agent:latest minikube image load target-app:latest See the Kubernetes Deployment guide for detailed deployment instructions. Verify Installation \u00b6 Docker Verification \u00b6 # Run a quick test with docker-compose docker-compose up # In another terminal, check if services are running curl http://localhost:8080 # Target app curl http://localhost:8000/metrics # Chaos agent metrics Local Verification \u00b6 # Activate your virtual environment source venv/bin/activate # Run tests pytest # Check Python version python --version # Should be 3.10+ Next Steps \u00b6 Once installation is complete: Review the Configuration Guide to customize your chaos experiments Follow the Quick Start Guide to run your first chaos test Explore different Failure Modes Troubleshooting \u00b6 Docker Issues \u00b6 If you encounter Docker-related issues: # Check Docker is running docker --version docker ps # Check Docker Compose docker-compose --version Python Version Issues \u00b6 Ensure you're using Python 3.10+: # Check Python version python --version # If needed, specify python3.10 python3.10 -m venv venv Permission Issues \u00b6 On Linux, you may need to add your user to the docker group: sudo usermod -aG docker $USER # Log out and back in for changes to take effect Getting Help \u00b6 If you encounter issues during installation: Check the FAQ Open an issue on GitHub Review existing issues for solutions","title":"Installation"},{"location":"getting-started/installation/#prerequisites","text":"Before installing Py-Chaos-Agent, ensure you have: Python 3.10 or higher Docker (for containerized deployment) kubectl (for Kubernetes deployment) Access to a test environment","title":"Prerequisites"},{"location":"getting-started/installation/#docker-installation","text":"The recommended way to run Py-Chaos-Agent is using Docker containers.","title":"Docker Installation"},{"location":"getting-started/installation/#pull-pre-built-images","text":"# Pull the chaos agent image docker pull itsothaimeen/py-chaos-agent:latest # Pull the target app image (for testing) docker pull itsothaimeen/target-app:latest","title":"Pull Pre-built Images"},{"location":"getting-started/installation/#build-from-source","text":"# Clone the repository git clone https://github.com/othaime-en/py-chaos-agent.git cd py-chaos-agent # Build the chaos agent image docker build -t py-chaos-agent:latest -f docker/Dockerfile . # Build the target app image docker build -t target-app:latest -f docker/Dockerfile.target .","title":"Build from Source"},{"location":"getting-started/installation/#local-development-installation","text":"For local development and testing: # Clone the repository git clone https://github.com/othaime-en/py-chaos-agent.git cd py-chaos-agent # Create a virtual environment python -m venv venv source venv/bin/activate # On Windows: venv\\Scripts\\activate # Install dependencies pip install -r requirements.txt # Install development dependencies (optional) pip install -r requirements-dev.txt","title":"Local Development Installation"},{"location":"getting-started/installation/#kubernetes-installation","text":"For Kubernetes deployment, you'll need: A running Kubernetes cluster (kind, minikube, or cloud-based) kubectl configured to access your cluster # Load images (for local testing with kind/minikube) kind load docker-image py-chaos-agent:latest kind load docker-image target-app:latest # Or for minikube minikube image load py-chaos-agent:latest minikube image load target-app:latest See the Kubernetes Deployment guide for detailed deployment instructions.","title":"Kubernetes Installation"},{"location":"getting-started/installation/#verify-installation","text":"","title":"Verify Installation"},{"location":"getting-started/installation/#docker-verification","text":"# Run a quick test with docker-compose docker-compose up # In another terminal, check if services are running curl http://localhost:8080 # Target app curl http://localhost:8000/metrics # Chaos agent metrics","title":"Docker Verification"},{"location":"getting-started/installation/#local-verification","text":"# Activate your virtual environment source venv/bin/activate # Run tests pytest # Check Python version python --version # Should be 3.10+","title":"Local Verification"},{"location":"getting-started/installation/#next-steps","text":"Once installation is complete: Review the Configuration Guide to customize your chaos experiments Follow the Quick Start Guide to run your first chaos test Explore different Failure Modes","title":"Next Steps"},{"location":"getting-started/installation/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"getting-started/installation/#docker-issues","text":"If you encounter Docker-related issues: # Check Docker is running docker --version docker ps # Check Docker Compose docker-compose --version","title":"Docker Issues"},{"location":"getting-started/installation/#python-version-issues","text":"Ensure you're using Python 3.10+: # Check Python version python --version # If needed, specify python3.10 python3.10 -m venv venv","title":"Python Version Issues"},{"location":"getting-started/installation/#permission-issues","text":"On Linux, you may need to add your user to the docker group: sudo usermod -aG docker $USER # Log out and back in for changes to take effect","title":"Permission Issues"},{"location":"getting-started/installation/#getting-help","text":"If you encounter issues during installation: Check the FAQ Open an issue on GitHub Review existing issues for solutions","title":"Getting Help"},{"location":"user-guide/architecture/","text":"Design Philosophy \u00b6 Py-Chaos-Agent follows the sidecar pattern, running as a separate container alongside your application within the same Kubernetes pod. This design provides: Process isolation : The chaos agent runs independently but can interact with target processes Network sharing : Both containers share the same network namespace for realistic network chaos Resource visibility : The agent can monitor and manipulate shared resources Easy deployment : No changes required to your application code System Architecture \u00b6 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Kubernetes Pod \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Target Application \u2502 \u2502 Py-Chaos-Agent \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Business logic \u2502 \u2502 - Config loader \u2502 \u2502 \u2502 \u2502 - Port 8080 \u2502 \u2502 - Failure injector \u2502 \u2502 \u2502 \u2502 - Processes visible \u2502\u25c4\u2500\u2500\u2500\u2524 - Metrics exporter \u2502 \u2502 \u2502 \u2502 to chaos agent \u2502 \u2502 - Port 8000 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 Shared Resources: \u2502 \u2502 - Process Namespace (shareProcessNamespace: true) \u2502 \u2502 - Network Namespace (via pod networking) \u2502 \u2502 - Network interfaces (eth0) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u25bc \u25bc Application Traffic Prometheus Scraping (port 8080) (port 8000/metrics) Component Breakdown \u00b6 1. Configuration Module ( src/config.py ) \u00b6 Loads and validates YAML configuration files. Uses dataclasses for type safety and easy serialization. Responsibilities: Parse YAML configuration Validate configuration values Provide structured configuration objects to other modules 2. Agent Core ( src/agent.py ) \u00b6 The main event loop that orchestrates chaos injections. Responsibilities: Load configuration on startup Start metrics server Iterate through configured failure types Apply probability checks before injection Dynamically import and execute failure modules Handle graceful shutdown and cleanup Flow: Start \u2192 Load Config \u2192 Start Metrics Server \u2192 Loop: - For each failure type: - Check if enabled - Roll probability dice - Import failure module - Execute injection - Sleep for interval - Repeat 3. Failure Modules ( src/failures/ ) \u00b6 Each failure type is implemented as a separate module with a standardized interface: def inject_ < type > ( config : dict , dry_run : bool = False ): \"\"\" Inject a specific type of failure. Args: config: Configuration dictionary for this failure type dry_run: If True, log what would happen without executing \"\"\" pass CPU Module ( cpu.py ) \u00b6 Uses multiprocessing to spawn CPU-intensive worker processes Each worker spins in a tight loop for the configured duration Number of cores determines number of worker processes Memory Module ( memory.py ) \u00b6 Allocates memory using bytearray to ensure actual memory consumption Runs in a background thread to avoid blocking other injections Fills allocated memory with varied data to prevent compression Process Module ( process.py ) \u00b6 Uses psutil to enumerate and manage processes Implements self-protection logic to avoid killing the chaos agent Supports graceful termination (SIGTERM) with fallback to SIGKILL Matches processes by name or command line Network Module ( network.py ) \u00b6 Uses Linux traffic control (tc) to inject network latency Requires NET_ADMIN capability in Kubernetes Automatically cleans up rules on shutdown Idempotent operations for reliability 4. Metrics Module ( src/metrics.py ) \u00b6 Exposes Prometheus metrics for observability. Metrics: chaos_injections_total : Counter with labels for failure_type and status chaos_injection_active : Gauge indicating currently active injections Implementation: Runs HTTP server in background thread Uses prometheus_client library Exposed on port 8000 at /metrics endpoint Data Flow \u00b6 Injection Cycle \u00b6 1. Agent wakes up after interval 2. Iterates through failure configurations 3. For each failure: a. Check if enabled (skip if not) b. Generate random number c. Compare to probability threshold d. If passes, dynamically import failure module e. Call inject_<type> function f. Update metrics 4. Sleep for configured interval 5. Repeat Metrics Flow \u00b6 1. Failure module begins injection \u2192 Set INJECTION_ACTIVE gauge to 1 2. During injection \u2192 Perform chaos operation 3. On completion (success or failure) \u2192 Increment INJECTIONS_TOTAL counter \u2192 Set INJECTION_ACTIVE gauge to 0 4. Prometheus scrapes metrics endpoint \u2192 Returns current metric values Kubernetes Integration \u00b6 Security Context \u00b6 The chaos agent requires elevated privileges: securityContext : capabilities : add : [ \"NET_ADMIN\" ] # For network chaos via tc command Namespace Sharing \u00b6 spec : shareProcessNamespace : true # Allows sidecar to see app processes This is critical for process termination chaos to work correctly. Volume Mounts \u00b6 Configuration is mounted as a ConfigMap: volumes : - name : config configMap : name : chaos-config volumeMounts : - name : config mountPath : /app/config.yaml subPath : config.yaml Safety Mechanisms \u00b6 Self-Protection \u00b6 The process killer includes logic to avoid terminating itself: Records own PID and parent PID Scans for all child processes Adds all to protected list Filters out any process matching \"chaos\" or \"agent.py\" in command line Only targets processes not in protected list Cleanup on Exit \u00b6 Signal handlers ensure graceful shutdown: signal . signal ( signal . SIGTERM , signal_handler ) signal . signal ( signal . SIGINT , signal_handler ) On shutdown: All network rules are removed Active injections are logged Metrics are flushed Dry Run Mode \u00b6 All injection functions support dry-run mode: Logs what would happen Updates metrics with \"skipped\" status No actual system modifications Extensibility \u00b6 Adding New Failure Types \u00b6 Create new module in src/failures/<type>.py Implement inject_<type>(config, dry_run) function Add to FAILURE_MODULES dict in agent.py Add configuration section to config.yaml Add tests in tests/test_failures.py Example skeleton: # src/failures/disk.py from ..metrics import INJECTIONS_TOTAL , INJECTION_ACTIVE def inject_disk ( config : dict , dry_run : bool = False ): operation = config . get ( \"operation\" , \"fill\" ) if dry_run : print ( f \"[DRY RUN] Would inject disk chaos: { operation } \" ) INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"skipped\" ) . inc () return print ( f \"[DISK] Injecting { operation } ...\" ) INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 1 ) try : # Implement disk chaos INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"success\" ) . inc () except Exception as e : INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"failed\" ) . inc () print ( f \"[DISK] Failed: { e } \" ) finally : INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 0 ) Performance Considerations \u00b6 Memory Efficiency \u00b6 Memory injection runs in separate thread to avoid blocking CPU injection uses multiprocessing for true parallel execution Network injection is non-blocking after tc command execution Resource Limits \u00b6 Consider setting resource limits on the chaos agent pod: resources : limits : cpu : 500m memory : 512Mi requests : cpu : 100m memory : 128Mi Metrics Impact \u00b6 The metrics server runs in a daemon thread with minimal overhead. Typical memory footprint is under 50MB for the entire agent. Dependencies \u00b6 Runtime Dependencies \u00b6 psutil : Process and system monitoring pyyaml : Configuration parsing prometheus_client : Metrics export System Dependencies \u00b6 iproute2 : Provides tc command for network chaos procps : Process utilities Kubernetes Dependencies \u00b6 shareProcessNamespace : Required for process chaos NET_ADMIN capability : Required for network chaos Limitations \u00b6 Single namespace : Only affects processes in the same pod Linux only : Relies on Linux-specific tools (tc, /proc) No rollback : Failed applications must recover naturally Synchronous execution : One failure type at a time per interval Network interface : Currently limited to single interface Future Enhancements \u00b6 Asynchronous injection for concurrent chaos Custom failure plugins via Python entry points gRPC API for external control Chaos scheduling (cron-like syntax) Multi-interface network chaos Container-level resource limits manipulation","title":"Architecture"},{"location":"user-guide/architecture/#design-philosophy","text":"Py-Chaos-Agent follows the sidecar pattern, running as a separate container alongside your application within the same Kubernetes pod. This design provides: Process isolation : The chaos agent runs independently but can interact with target processes Network sharing : Both containers share the same network namespace for realistic network chaos Resource visibility : The agent can monitor and manipulate shared resources Easy deployment : No changes required to your application code","title":"Design Philosophy"},{"location":"user-guide/architecture/#system-architecture","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Kubernetes Pod \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Target Application \u2502 \u2502 Py-Chaos-Agent \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 - Business logic \u2502 \u2502 - Config loader \u2502 \u2502 \u2502 \u2502 - Port 8080 \u2502 \u2502 - Failure injector \u2502 \u2502 \u2502 \u2502 - Processes visible \u2502\u25c4\u2500\u2500\u2500\u2524 - Metrics exporter \u2502 \u2502 \u2502 \u2502 to chaos agent \u2502 \u2502 - Port 8000 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 Shared Resources: \u2502 \u2502 - Process Namespace (shareProcessNamespace: true) \u2502 \u2502 - Network Namespace (via pod networking) \u2502 \u2502 - Network interfaces (eth0) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u25bc \u25bc Application Traffic Prometheus Scraping (port 8080) (port 8000/metrics)","title":"System Architecture"},{"location":"user-guide/architecture/#component-breakdown","text":"","title":"Component Breakdown"},{"location":"user-guide/architecture/#1-configuration-module-srcconfigpy","text":"Loads and validates YAML configuration files. Uses dataclasses for type safety and easy serialization. Responsibilities: Parse YAML configuration Validate configuration values Provide structured configuration objects to other modules","title":"1. Configuration Module (src/config.py)"},{"location":"user-guide/architecture/#2-agent-core-srcagentpy","text":"The main event loop that orchestrates chaos injections. Responsibilities: Load configuration on startup Start metrics server Iterate through configured failure types Apply probability checks before injection Dynamically import and execute failure modules Handle graceful shutdown and cleanup Flow: Start \u2192 Load Config \u2192 Start Metrics Server \u2192 Loop: - For each failure type: - Check if enabled - Roll probability dice - Import failure module - Execute injection - Sleep for interval - Repeat","title":"2. Agent Core (src/agent.py)"},{"location":"user-guide/architecture/#3-failure-modules-srcfailures","text":"Each failure type is implemented as a separate module with a standardized interface: def inject_ < type > ( config : dict , dry_run : bool = False ): \"\"\" Inject a specific type of failure. Args: config: Configuration dictionary for this failure type dry_run: If True, log what would happen without executing \"\"\" pass","title":"3. Failure Modules (src/failures/)"},{"location":"user-guide/architecture/#cpu-module-cpupy","text":"Uses multiprocessing to spawn CPU-intensive worker processes Each worker spins in a tight loop for the configured duration Number of cores determines number of worker processes","title":"CPU Module (cpu.py)"},{"location":"user-guide/architecture/#memory-module-memorypy","text":"Allocates memory using bytearray to ensure actual memory consumption Runs in a background thread to avoid blocking other injections Fills allocated memory with varied data to prevent compression","title":"Memory Module (memory.py)"},{"location":"user-guide/architecture/#process-module-processpy","text":"Uses psutil to enumerate and manage processes Implements self-protection logic to avoid killing the chaos agent Supports graceful termination (SIGTERM) with fallback to SIGKILL Matches processes by name or command line","title":"Process Module (process.py)"},{"location":"user-guide/architecture/#network-module-networkpy","text":"Uses Linux traffic control (tc) to inject network latency Requires NET_ADMIN capability in Kubernetes Automatically cleans up rules on shutdown Idempotent operations for reliability","title":"Network Module (network.py)"},{"location":"user-guide/architecture/#4-metrics-module-srcmetricspy","text":"Exposes Prometheus metrics for observability. Metrics: chaos_injections_total : Counter with labels for failure_type and status chaos_injection_active : Gauge indicating currently active injections Implementation: Runs HTTP server in background thread Uses prometheus_client library Exposed on port 8000 at /metrics endpoint","title":"4. Metrics Module (src/metrics.py)"},{"location":"user-guide/architecture/#data-flow","text":"","title":"Data Flow"},{"location":"user-guide/architecture/#injection-cycle","text":"1. Agent wakes up after interval 2. Iterates through failure configurations 3. For each failure: a. Check if enabled (skip if not) b. Generate random number c. Compare to probability threshold d. If passes, dynamically import failure module e. Call inject_<type> function f. Update metrics 4. Sleep for configured interval 5. Repeat","title":"Injection Cycle"},{"location":"user-guide/architecture/#metrics-flow","text":"1. Failure module begins injection \u2192 Set INJECTION_ACTIVE gauge to 1 2. During injection \u2192 Perform chaos operation 3. On completion (success or failure) \u2192 Increment INJECTIONS_TOTAL counter \u2192 Set INJECTION_ACTIVE gauge to 0 4. Prometheus scrapes metrics endpoint \u2192 Returns current metric values","title":"Metrics Flow"},{"location":"user-guide/architecture/#kubernetes-integration","text":"","title":"Kubernetes Integration"},{"location":"user-guide/architecture/#security-context","text":"The chaos agent requires elevated privileges: securityContext : capabilities : add : [ \"NET_ADMIN\" ] # For network chaos via tc command","title":"Security Context"},{"location":"user-guide/architecture/#namespace-sharing","text":"spec : shareProcessNamespace : true # Allows sidecar to see app processes This is critical for process termination chaos to work correctly.","title":"Namespace Sharing"},{"location":"user-guide/architecture/#volume-mounts","text":"Configuration is mounted as a ConfigMap: volumes : - name : config configMap : name : chaos-config volumeMounts : - name : config mountPath : /app/config.yaml subPath : config.yaml","title":"Volume Mounts"},{"location":"user-guide/architecture/#safety-mechanisms","text":"","title":"Safety Mechanisms"},{"location":"user-guide/architecture/#self-protection","text":"The process killer includes logic to avoid terminating itself: Records own PID and parent PID Scans for all child processes Adds all to protected list Filters out any process matching \"chaos\" or \"agent.py\" in command line Only targets processes not in protected list","title":"Self-Protection"},{"location":"user-guide/architecture/#cleanup-on-exit","text":"Signal handlers ensure graceful shutdown: signal . signal ( signal . SIGTERM , signal_handler ) signal . signal ( signal . SIGINT , signal_handler ) On shutdown: All network rules are removed Active injections are logged Metrics are flushed","title":"Cleanup on Exit"},{"location":"user-guide/architecture/#dry-run-mode","text":"All injection functions support dry-run mode: Logs what would happen Updates metrics with \"skipped\" status No actual system modifications","title":"Dry Run Mode"},{"location":"user-guide/architecture/#extensibility","text":"","title":"Extensibility"},{"location":"user-guide/architecture/#adding-new-failure-types","text":"Create new module in src/failures/<type>.py Implement inject_<type>(config, dry_run) function Add to FAILURE_MODULES dict in agent.py Add configuration section to config.yaml Add tests in tests/test_failures.py Example skeleton: # src/failures/disk.py from ..metrics import INJECTIONS_TOTAL , INJECTION_ACTIVE def inject_disk ( config : dict , dry_run : bool = False ): operation = config . get ( \"operation\" , \"fill\" ) if dry_run : print ( f \"[DRY RUN] Would inject disk chaos: { operation } \" ) INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"skipped\" ) . inc () return print ( f \"[DISK] Injecting { operation } ...\" ) INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 1 ) try : # Implement disk chaos INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"success\" ) . inc () except Exception as e : INJECTIONS_TOTAL . labels ( failure_type = \"disk\" , status = \"failed\" ) . inc () print ( f \"[DISK] Failed: { e } \" ) finally : INJECTION_ACTIVE . labels ( failure_type = \"disk\" ) . set ( 0 )","title":"Adding New Failure Types"},{"location":"user-guide/architecture/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"user-guide/architecture/#memory-efficiency","text":"Memory injection runs in separate thread to avoid blocking CPU injection uses multiprocessing for true parallel execution Network injection is non-blocking after tc command execution","title":"Memory Efficiency"},{"location":"user-guide/architecture/#resource-limits","text":"Consider setting resource limits on the chaos agent pod: resources : limits : cpu : 500m memory : 512Mi requests : cpu : 100m memory : 128Mi","title":"Resource Limits"},{"location":"user-guide/architecture/#metrics-impact","text":"The metrics server runs in a daemon thread with minimal overhead. Typical memory footprint is under 50MB for the entire agent.","title":"Metrics Impact"},{"location":"user-guide/architecture/#dependencies","text":"","title":"Dependencies"},{"location":"user-guide/architecture/#runtime-dependencies","text":"psutil : Process and system monitoring pyyaml : Configuration parsing prometheus_client : Metrics export","title":"Runtime Dependencies"},{"location":"user-guide/architecture/#system-dependencies","text":"iproute2 : Provides tc command for network chaos procps : Process utilities","title":"System Dependencies"},{"location":"user-guide/architecture/#kubernetes-dependencies","text":"shareProcessNamespace : Required for process chaos NET_ADMIN capability : Required for network chaos","title":"Kubernetes Dependencies"},{"location":"user-guide/architecture/#limitations","text":"Single namespace : Only affects processes in the same pod Linux only : Relies on Linux-specific tools (tc, /proc) No rollback : Failed applications must recover naturally Synchronous execution : One failure type at a time per interval Network interface : Currently limited to single interface","title":"Limitations"},{"location":"user-guide/architecture/#future-enhancements","text":"Asynchronous injection for concurrent chaos Custom failure plugins via Python entry points gRPC API for external control Chaos scheduling (cron-like syntax) Multi-interface network chaos Container-level resource limits manipulation","title":"Future Enhancements"},{"location":"user-guide/troubleshooting/","text":"Common Issues and Solutions \u00b6 Agent Not Starting \u00b6 Symptom \u00b6 kubectl get pods -n chaos-demo # NAME READY STATUS RESTARTS AGE # resilient-app-xxx-xxx 1/2 CrashLoopBackOff 5 3m Diagnosis \u00b6 # Check agent logs kubectl logs -n chaos-demo <pod-name> -c chaos-agent # Common errors: # - \"FileNotFoundError: config.yaml\" # - \"ModuleNotFoundError: No module named 'psutil'\" # - \"PermissionError: [Errno 13]\" Solutions \u00b6 Config file not found: # Verify ConfigMap exists kubectl get configmap -n chaos-demo chaos-config # Verify mount path kubectl describe pod -n chaos-demo <pod-name> | grep -A 10 Mounts # Fix: Ensure ConfigMap is properly mounted Missing dependencies: # Rebuild Docker image with all dependencies docker build -t py-chaos-agent:latest -f docker/Dockerfile . # Verify requirements.txt includes all packages cat requirements.txt Permission issues: # Ensure container runs as root for chaos operations securityContext : runAsUser : 0 capabilities : add : [ \"NET_ADMIN\" ] Chaos Not Triggering \u00b6 Symptom \u00b6 # Metrics show only skipped injections curl localhost:8000/metrics | grep chaos_injections_total # chaos_injections_total{failure_type=\"cpu\",status=\"skipped\"} 100 # chaos_injections_total{failure_type=\"cpu\",status=\"success\"} 0 Diagnosis \u00b6 # Check configuration kubectl get configmap -n chaos-demo chaos-config -o yaml # Check agent logs for clues kubectl logs -n chaos-demo <pod-name> -c chaos-agent -f Common Causes and Fixes \u00b6 1. Dry-run mode enabled: # Check config agent : dry_run : true # This prevents actual chaos! # Fix: Set to false agent : dry_run : false 2. Low probability: # With probability 0.1 and interval 30s: # Expected: ~2 injections per hour failures : cpu : probability : 0.1 # Very low! # Fix: Increase for testing failures : cpu : probability : 0.5 # Much more likely 3. All failures disabled: failures : cpu : enabled : false memory : enabled : false process : enabled : false network : enabled : false # Fix: Enable at least one 4. Process not found: # For process failures, target must exist kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep \"No killable process\" # Check what processes are running kubectl exec -n chaos-demo <pod-name> -c target-app -- ps aux # Fix: Update target_name to match actual process Network Chaos Not Working \u00b6 Symptom \u00b6 [NETWORK] Failed: Operation not permitted chaos_injections_total{failure_type=\"network\",status=\"failed\"} increasing Diagnosis \u00b6 # Check if NET_ADMIN capability is granted kubectl get pod -n chaos-demo <pod-name> -o yaml | grep -A 5 capabilities Solution \u00b6 # Add NET_ADMIN capability containers : - name : chaos-agent securityContext : capabilities : add : [ \"NET_ADMIN\" ] # Or use privileged mode (less secure) containers : - name : chaos-agent securityContext : privileged : true Verify Fix \u00b6 # Recreate pod kubectl delete pod -n chaos-demo <pod-name> # Check logs kubectl logs -n chaos-demo <pod-name> -c chaos-agent -f # Should see: [NETWORK] Adding Xms latency... Process Kills Not Working \u00b6 Symptom \u00b6 [PROCESS] No killable process named 'myapp' found Diagnosis \u00b6 # Check what processes are visible kubectl exec -n chaos-demo <pod-name> -c chaos-agent -- ps aux # If you don't see target app processes, check shareProcessNamespace kubectl get pod -n chaos-demo <pod-name> -o yaml | grep shareProcessNamespace Solution \u00b6 # Enable process namespace sharing spec : shareProcessNamespace : true # CRITICAL for process chaos containers : - name : target-app # ... - name : chaos-agent # ... Verify Fix \u00b6 # Delete and recreate pod kubectl delete pod -n chaos-demo <pod-name> # Verify processes are visible kubectl exec -n chaos-demo <pod-name> -c chaos-agent -- ps aux | grep target High Failure Rate \u00b6 Symptom \u00b6 chaos_injections_total{failure_type=\"network\",status=\"failed\"} 45 chaos_injections_total{failure_type=\"network\",status=\"success\"} 5 Diagnosis \u00b6 # Get detailed error messages kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep \"Failed:\" # Common errors: # - \"RTNETLINK answers: File exists\" (network rules conflict) # - \"Cannot allocate memory\" (insufficient memory) # - \"Command not found: tc\" (missing tools) Solutions \u00b6 Network rules conflict: # Clean up manually kubectl exec -n chaos-demo <pod-name> -c chaos-agent -- tc qdisc del dev eth0 root 2 >/dev/null # Or restart pod kubectl delete pod -n chaos-demo <pod-name> Insufficient memory: # Reduce memory allocation or increase pod limits failures : memory : mb : 100 # Reduced from 500 # Or increase pod resources resources : limits : memory : 1Gi # Increased limit Missing tools: # Ensure Dockerfile installs all required tools RUN apt-get update && apt-get install -y \\ iproute2 \\ procps \\ && rm -rf /var/lib/apt/lists/* Metrics Not Appearing \u00b6 Symptom \u00b6 curl localhost:8000/metrics # curl: (7) Failed to connect to localhost port 8000: Connection refused Diagnosis \u00b6 # Check if metrics server started kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep \"Metrics\" # Should see: [Metrics] Prometheus exporter running on :8000 # Check if port is exposed kubectl get pod -n chaos-demo <pod-name> -o yaml | grep -A 5 ports Solutions \u00b6 Port not exposed: containers : - name : chaos-agent ports : - containerPort : 8000 name : metrics Port forward not working: # Kill existing port forwards pkill -f \"port-forward\" # Create new port forward kubectl port-forward -n chaos-demo <pod-name> 8000 :8000 # Or use service kubectl port-forward -n chaos-demo svc/resilient-app 8000 :8000 Metrics server crashed: # Check for exceptions in metrics.py # Increase debugging import logging logging . basicConfig ( level = logging . DEBUG ) Docker Compose Issues \u00b6 Symptom \u00b6 docker-compose up # ERROR: for chaos-agent Cannot start service chaos-agent: # error creating network: permission denied Solutions \u00b6 Permission denied: # Run with sudo (Linux) sudo docker-compose up # Or add user to docker group sudo usermod -aG docker $USER newgrp docker Containers can't communicate: # Check network docker network ls docker network inspect py-chaos-agent_default # Verify network mode in docker-compose.yml network_mode: \"service:target-app\" # Correct Volume mount issues: # Check file exists ls -la config.yaml # Verify mount in docker-compose.yml volumes: - ./config.yaml:/app/config.yaml:ro # Debug inside container docker-compose run --rm chaos-agent ls -la /app/ Kubernetes Deployment Issues \u00b6 Image Pull Errors \u00b6 kubectl describe pod -n chaos-demo <pod-name> # Events: # Failed to pull image: ImagePullBackOff Solutions: # For local images (minikube/kind) eval $( minikube docker-env ) # or kind load docker-image py-chaos-agent:latest # For ECR aws ecr get-login-password --region us-east-1 | \\ docker login --username AWS --password-stdin <ecr-url> # Verify image exists docker images | grep chaos-agent Pod Stuck in Pending \u00b6 kubectl describe pod -n chaos-demo <pod-name> # Events: # FailedScheduling: 0/3 nodes available: insufficient memory Solutions: # Reduce resource requests resources : requests : cpu : 100m # Reduced memory : 128Mi # Reduced limits : cpu : 500m memory : 512Mi Configuration Issues \u00b6 Invalid YAML Syntax \u00b6 kubectl apply -f config.yaml # error: error parsing config.yaml: yaml: line 10: did not find expected key Solutions: # Validate YAML syntax python -c \"import yaml; yaml.safe_load(open('config.yaml'))\" # Use online validator: https://www.yamllint.com/ # Common issues: # - Incorrect indentation (use spaces, not tabs) # - Missing colons # - Unquoted special characters Configuration Not Loading \u00b6 # Agent keeps using old configuration kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep CONFIG # [CONFIG] Interval: 10s # Old value! Solutions: # ConfigMap updates don't auto-reload pods # Must delete pod to pick up changes kubectl delete pod -n chaos-demo <pod-name> # Or use a rolling restart kubectl rollout restart deployment -n chaos-demo resilient-app # Verify ConfigMap updated kubectl get configmap -n chaos-demo chaos-config -o yaml Performance Issues \u00b6 High CPU Usage \u00b6 kubectl top pod -n chaos-demo # NAME CPU(cores) MEMORY(bytes) # resilient-app-xxx-xxx 950m 150Mi Diagnosis: # Check if CPU chaos is stuck kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep CPU # Check metrics curl localhost:8000/metrics | grep chaos_injection_active # chaos_injection_active{failure_type=\"cpu\"} 1 # Still active! Solutions: # Reduce CPU chaos intensity failures : cpu : cores : 1 # Reduced from 4 duration_seconds : 5 # Reduced from 30 # Or adjust interval agent : interval_seconds : 60 # Increased from 10 Memory Leak \u00b6 kubectl top pod -n chaos-demo # NAME CPU(cores) MEMORY(bytes) # resilient-app-xxx-xxx 100m 950Mi # Increasing! Solutions: # Check for stuck memory injections curl localhost:8000/metrics | grep memory # Set proper resource limits resources: limits: memory: 512Mi # Pod will be OOM killed if exceeded # Restart pod periodically if needed kubectl delete pod -n chaos-demo <pod-name> Debugging Techniques \u00b6 Enable Debug Logging \u00b6 # Add to src/agent.py import logging logging . basicConfig ( level = logging . DEBUG , format = '[ %(asctime)s ] %(levelname)s : %(message)s ' ) Interactive Debugging \u00b6 # Access chaos agent container kubectl exec -it -n chaos-demo <pod-name> -c chaos-agent -- /bin/bash # Test commands manually tc qdisc show dev eth0 ps aux | grep target python -c \"import psutil; print(psutil.cpu_percent())\" Check System Resources \u00b6 # Inside container free -h # Memory df -h # Disk ip addr show # Network interfaces ps auxf # Process tree Validate Metrics Manually \u00b6 # Python script to check metrics import requests response = requests . get ( 'http://localhost:8000/metrics' ) for line in response . text . split ( ' \\n ' ): if 'chaos_' in line and not line . startswith ( '#' ): print ( line ) Getting Help \u00b6 Before Opening an Issue \u00b6 Check logs: kubectl logs -n chaos-demo <pod-name> -c chaos-agent > agent.log kubectl describe pod -n chaos-demo <pod-name> > pod-describe.txt Collect configuration: kubectl get configmap -n chaos-demo chaos-config -o yaml > config.yaml kubectl get pod -n chaos-demo <pod-name> -o yaml > pod.yaml Get metrics: curl localhost:8000/metrics > metrics.txt Document steps: What you tried What you expected What actually happened Environment details (Kubernetes version, cloud provider) Issue Template \u00b6 ## Environment - Kubernetes version: - Cloud provider: - Chaos agent version: ## Problem Description [Clear description of the issue] ## Steps to Reproduce 1. 2. 3. ## Expected Behavior [What should happen] ## Actual Behavior [What actually happens] ## Logs [Paste relevant logs] ## Configuration ```yaml [Paste relevant config] ## Additional Resources - [Kubernetes Troubleshooting Guide](https://kubernetes.io/docs/tasks/debug/) - [Docker Debugging Guide](https://docs.docker.com/config/containers/troubleshoot/) - [Prometheus Troubleshooting](https://prometheus.io/docs/prometheus/latest/troubleshooting/)","title":"Troubleshooting"},{"location":"user-guide/troubleshooting/#common-issues-and-solutions","text":"","title":"Common Issues and Solutions"},{"location":"user-guide/troubleshooting/#agent-not-starting","text":"","title":"Agent Not Starting"},{"location":"user-guide/troubleshooting/#symptom","text":"kubectl get pods -n chaos-demo # NAME READY STATUS RESTARTS AGE # resilient-app-xxx-xxx 1/2 CrashLoopBackOff 5 3m","title":"Symptom"},{"location":"user-guide/troubleshooting/#diagnosis","text":"# Check agent logs kubectl logs -n chaos-demo <pod-name> -c chaos-agent # Common errors: # - \"FileNotFoundError: config.yaml\" # - \"ModuleNotFoundError: No module named 'psutil'\" # - \"PermissionError: [Errno 13]\"","title":"Diagnosis"},{"location":"user-guide/troubleshooting/#solutions","text":"Config file not found: # Verify ConfigMap exists kubectl get configmap -n chaos-demo chaos-config # Verify mount path kubectl describe pod -n chaos-demo <pod-name> | grep -A 10 Mounts # Fix: Ensure ConfigMap is properly mounted Missing dependencies: # Rebuild Docker image with all dependencies docker build -t py-chaos-agent:latest -f docker/Dockerfile . # Verify requirements.txt includes all packages cat requirements.txt Permission issues: # Ensure container runs as root for chaos operations securityContext : runAsUser : 0 capabilities : add : [ \"NET_ADMIN\" ]","title":"Solutions"},{"location":"user-guide/troubleshooting/#chaos-not-triggering","text":"","title":"Chaos Not Triggering"},{"location":"user-guide/troubleshooting/#symptom_1","text":"# Metrics show only skipped injections curl localhost:8000/metrics | grep chaos_injections_total # chaos_injections_total{failure_type=\"cpu\",status=\"skipped\"} 100 # chaos_injections_total{failure_type=\"cpu\",status=\"success\"} 0","title":"Symptom"},{"location":"user-guide/troubleshooting/#diagnosis_1","text":"# Check configuration kubectl get configmap -n chaos-demo chaos-config -o yaml # Check agent logs for clues kubectl logs -n chaos-demo <pod-name> -c chaos-agent -f","title":"Diagnosis"},{"location":"user-guide/troubleshooting/#common-causes-and-fixes","text":"1. Dry-run mode enabled: # Check config agent : dry_run : true # This prevents actual chaos! # Fix: Set to false agent : dry_run : false 2. Low probability: # With probability 0.1 and interval 30s: # Expected: ~2 injections per hour failures : cpu : probability : 0.1 # Very low! # Fix: Increase for testing failures : cpu : probability : 0.5 # Much more likely 3. All failures disabled: failures : cpu : enabled : false memory : enabled : false process : enabled : false network : enabled : false # Fix: Enable at least one 4. Process not found: # For process failures, target must exist kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep \"No killable process\" # Check what processes are running kubectl exec -n chaos-demo <pod-name> -c target-app -- ps aux # Fix: Update target_name to match actual process","title":"Common Causes and Fixes"},{"location":"user-guide/troubleshooting/#network-chaos-not-working","text":"","title":"Network Chaos Not Working"},{"location":"user-guide/troubleshooting/#symptom_2","text":"[NETWORK] Failed: Operation not permitted chaos_injections_total{failure_type=\"network\",status=\"failed\"} increasing","title":"Symptom"},{"location":"user-guide/troubleshooting/#diagnosis_2","text":"# Check if NET_ADMIN capability is granted kubectl get pod -n chaos-demo <pod-name> -o yaml | grep -A 5 capabilities","title":"Diagnosis"},{"location":"user-guide/troubleshooting/#solution","text":"# Add NET_ADMIN capability containers : - name : chaos-agent securityContext : capabilities : add : [ \"NET_ADMIN\" ] # Or use privileged mode (less secure) containers : - name : chaos-agent securityContext : privileged : true","title":"Solution"},{"location":"user-guide/troubleshooting/#verify-fix","text":"# Recreate pod kubectl delete pod -n chaos-demo <pod-name> # Check logs kubectl logs -n chaos-demo <pod-name> -c chaos-agent -f # Should see: [NETWORK] Adding Xms latency...","title":"Verify Fix"},{"location":"user-guide/troubleshooting/#process-kills-not-working","text":"","title":"Process Kills Not Working"},{"location":"user-guide/troubleshooting/#symptom_3","text":"[PROCESS] No killable process named 'myapp' found","title":"Symptom"},{"location":"user-guide/troubleshooting/#diagnosis_3","text":"# Check what processes are visible kubectl exec -n chaos-demo <pod-name> -c chaos-agent -- ps aux # If you don't see target app processes, check shareProcessNamespace kubectl get pod -n chaos-demo <pod-name> -o yaml | grep shareProcessNamespace","title":"Diagnosis"},{"location":"user-guide/troubleshooting/#solution_1","text":"# Enable process namespace sharing spec : shareProcessNamespace : true # CRITICAL for process chaos containers : - name : target-app # ... - name : chaos-agent # ...","title":"Solution"},{"location":"user-guide/troubleshooting/#verify-fix_1","text":"# Delete and recreate pod kubectl delete pod -n chaos-demo <pod-name> # Verify processes are visible kubectl exec -n chaos-demo <pod-name> -c chaos-agent -- ps aux | grep target","title":"Verify Fix"},{"location":"user-guide/troubleshooting/#high-failure-rate","text":"","title":"High Failure Rate"},{"location":"user-guide/troubleshooting/#symptom_4","text":"chaos_injections_total{failure_type=\"network\",status=\"failed\"} 45 chaos_injections_total{failure_type=\"network\",status=\"success\"} 5","title":"Symptom"},{"location":"user-guide/troubleshooting/#diagnosis_4","text":"# Get detailed error messages kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep \"Failed:\" # Common errors: # - \"RTNETLINK answers: File exists\" (network rules conflict) # - \"Cannot allocate memory\" (insufficient memory) # - \"Command not found: tc\" (missing tools)","title":"Diagnosis"},{"location":"user-guide/troubleshooting/#solutions_1","text":"Network rules conflict: # Clean up manually kubectl exec -n chaos-demo <pod-name> -c chaos-agent -- tc qdisc del dev eth0 root 2 >/dev/null # Or restart pod kubectl delete pod -n chaos-demo <pod-name> Insufficient memory: # Reduce memory allocation or increase pod limits failures : memory : mb : 100 # Reduced from 500 # Or increase pod resources resources : limits : memory : 1Gi # Increased limit Missing tools: # Ensure Dockerfile installs all required tools RUN apt-get update && apt-get install -y \\ iproute2 \\ procps \\ && rm -rf /var/lib/apt/lists/*","title":"Solutions"},{"location":"user-guide/troubleshooting/#metrics-not-appearing","text":"","title":"Metrics Not Appearing"},{"location":"user-guide/troubleshooting/#symptom_5","text":"curl localhost:8000/metrics # curl: (7) Failed to connect to localhost port 8000: Connection refused","title":"Symptom"},{"location":"user-guide/troubleshooting/#diagnosis_5","text":"# Check if metrics server started kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep \"Metrics\" # Should see: [Metrics] Prometheus exporter running on :8000 # Check if port is exposed kubectl get pod -n chaos-demo <pod-name> -o yaml | grep -A 5 ports","title":"Diagnosis"},{"location":"user-guide/troubleshooting/#solutions_2","text":"Port not exposed: containers : - name : chaos-agent ports : - containerPort : 8000 name : metrics Port forward not working: # Kill existing port forwards pkill -f \"port-forward\" # Create new port forward kubectl port-forward -n chaos-demo <pod-name> 8000 :8000 # Or use service kubectl port-forward -n chaos-demo svc/resilient-app 8000 :8000 Metrics server crashed: # Check for exceptions in metrics.py # Increase debugging import logging logging . basicConfig ( level = logging . DEBUG )","title":"Solutions"},{"location":"user-guide/troubleshooting/#docker-compose-issues","text":"","title":"Docker Compose Issues"},{"location":"user-guide/troubleshooting/#symptom_6","text":"docker-compose up # ERROR: for chaos-agent Cannot start service chaos-agent: # error creating network: permission denied","title":"Symptom"},{"location":"user-guide/troubleshooting/#solutions_3","text":"Permission denied: # Run with sudo (Linux) sudo docker-compose up # Or add user to docker group sudo usermod -aG docker $USER newgrp docker Containers can't communicate: # Check network docker network ls docker network inspect py-chaos-agent_default # Verify network mode in docker-compose.yml network_mode: \"service:target-app\" # Correct Volume mount issues: # Check file exists ls -la config.yaml # Verify mount in docker-compose.yml volumes: - ./config.yaml:/app/config.yaml:ro # Debug inside container docker-compose run --rm chaos-agent ls -la /app/","title":"Solutions"},{"location":"user-guide/troubleshooting/#kubernetes-deployment-issues","text":"","title":"Kubernetes Deployment Issues"},{"location":"user-guide/troubleshooting/#image-pull-errors","text":"kubectl describe pod -n chaos-demo <pod-name> # Events: # Failed to pull image: ImagePullBackOff Solutions: # For local images (minikube/kind) eval $( minikube docker-env ) # or kind load docker-image py-chaos-agent:latest # For ECR aws ecr get-login-password --region us-east-1 | \\ docker login --username AWS --password-stdin <ecr-url> # Verify image exists docker images | grep chaos-agent","title":"Image Pull Errors"},{"location":"user-guide/troubleshooting/#pod-stuck-in-pending","text":"kubectl describe pod -n chaos-demo <pod-name> # Events: # FailedScheduling: 0/3 nodes available: insufficient memory Solutions: # Reduce resource requests resources : requests : cpu : 100m # Reduced memory : 128Mi # Reduced limits : cpu : 500m memory : 512Mi","title":"Pod Stuck in Pending"},{"location":"user-guide/troubleshooting/#configuration-issues","text":"","title":"Configuration Issues"},{"location":"user-guide/troubleshooting/#invalid-yaml-syntax","text":"kubectl apply -f config.yaml # error: error parsing config.yaml: yaml: line 10: did not find expected key Solutions: # Validate YAML syntax python -c \"import yaml; yaml.safe_load(open('config.yaml'))\" # Use online validator: https://www.yamllint.com/ # Common issues: # - Incorrect indentation (use spaces, not tabs) # - Missing colons # - Unquoted special characters","title":"Invalid YAML Syntax"},{"location":"user-guide/troubleshooting/#configuration-not-loading","text":"# Agent keeps using old configuration kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep CONFIG # [CONFIG] Interval: 10s # Old value! Solutions: # ConfigMap updates don't auto-reload pods # Must delete pod to pick up changes kubectl delete pod -n chaos-demo <pod-name> # Or use a rolling restart kubectl rollout restart deployment -n chaos-demo resilient-app # Verify ConfigMap updated kubectl get configmap -n chaos-demo chaos-config -o yaml","title":"Configuration Not Loading"},{"location":"user-guide/troubleshooting/#performance-issues","text":"","title":"Performance Issues"},{"location":"user-guide/troubleshooting/#high-cpu-usage","text":"kubectl top pod -n chaos-demo # NAME CPU(cores) MEMORY(bytes) # resilient-app-xxx-xxx 950m 150Mi Diagnosis: # Check if CPU chaos is stuck kubectl logs -n chaos-demo <pod-name> -c chaos-agent | grep CPU # Check metrics curl localhost:8000/metrics | grep chaos_injection_active # chaos_injection_active{failure_type=\"cpu\"} 1 # Still active! Solutions: # Reduce CPU chaos intensity failures : cpu : cores : 1 # Reduced from 4 duration_seconds : 5 # Reduced from 30 # Or adjust interval agent : interval_seconds : 60 # Increased from 10","title":"High CPU Usage"},{"location":"user-guide/troubleshooting/#memory-leak","text":"kubectl top pod -n chaos-demo # NAME CPU(cores) MEMORY(bytes) # resilient-app-xxx-xxx 100m 950Mi # Increasing! Solutions: # Check for stuck memory injections curl localhost:8000/metrics | grep memory # Set proper resource limits resources: limits: memory: 512Mi # Pod will be OOM killed if exceeded # Restart pod periodically if needed kubectl delete pod -n chaos-demo <pod-name>","title":"Memory Leak"},{"location":"user-guide/troubleshooting/#debugging-techniques","text":"","title":"Debugging Techniques"},{"location":"user-guide/troubleshooting/#enable-debug-logging","text":"# Add to src/agent.py import logging logging . basicConfig ( level = logging . DEBUG , format = '[ %(asctime)s ] %(levelname)s : %(message)s ' )","title":"Enable Debug Logging"},{"location":"user-guide/troubleshooting/#interactive-debugging","text":"# Access chaos agent container kubectl exec -it -n chaos-demo <pod-name> -c chaos-agent -- /bin/bash # Test commands manually tc qdisc show dev eth0 ps aux | grep target python -c \"import psutil; print(psutil.cpu_percent())\"","title":"Interactive Debugging"},{"location":"user-guide/troubleshooting/#check-system-resources","text":"# Inside container free -h # Memory df -h # Disk ip addr show # Network interfaces ps auxf # Process tree","title":"Check System Resources"},{"location":"user-guide/troubleshooting/#validate-metrics-manually","text":"# Python script to check metrics import requests response = requests . get ( 'http://localhost:8000/metrics' ) for line in response . text . split ( ' \\n ' ): if 'chaos_' in line and not line . startswith ( '#' ): print ( line )","title":"Validate Metrics Manually"},{"location":"user-guide/troubleshooting/#getting-help","text":"","title":"Getting Help"},{"location":"user-guide/troubleshooting/#before-opening-an-issue","text":"Check logs: kubectl logs -n chaos-demo <pod-name> -c chaos-agent > agent.log kubectl describe pod -n chaos-demo <pod-name> > pod-describe.txt Collect configuration: kubectl get configmap -n chaos-demo chaos-config -o yaml > config.yaml kubectl get pod -n chaos-demo <pod-name> -o yaml > pod.yaml Get metrics: curl localhost:8000/metrics > metrics.txt Document steps: What you tried What you expected What actually happened Environment details (Kubernetes version, cloud provider)","title":"Before Opening an Issue"},{"location":"user-guide/troubleshooting/#issue-template","text":"## Environment - Kubernetes version: - Cloud provider: - Chaos agent version: ## Problem Description [Clear description of the issue] ## Steps to Reproduce 1. 2. 3. ## Expected Behavior [What should happen] ## Actual Behavior [What actually happens] ## Logs [Paste relevant logs] ## Configuration ```yaml [Paste relevant config] ## Additional Resources - [Kubernetes Troubleshooting Guide](https://kubernetes.io/docs/tasks/debug/) - [Docker Debugging Guide](https://docs.docker.com/config/containers/troubleshoot/) - [Prometheus Troubleshooting](https://prometheus.io/docs/prometheus/latest/troubleshooting/)","title":"Issue Template"}]}